<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><title>iOS 中的各种锁 | Anrue Blod</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="[object Object]"><meta name="designer" content="minfive"><meta name="keywords" content="iOS, Pyton, Anrue, Anrue blog, iOS博客, 程序员"><meta name="description" content="这般花花草草由人恋，酸酸楚楚随人愿，便生生死死无人怨！"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="https://github.com/anru1314/2018/11/09/iOS/2018-11-09-iOS-中的各种锁/index.html"><link rel="icon" type="image/png" href="/img/favicon.png" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="Anrue"><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart=""><div id="page-loading" class="page page-loading" style="background-image:url(http://oo12ugek5.bkt.clouddn.com/blog/images/loader.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="Anrue" alt="Anrue"><img src="/img/logo.png" alt="Anrue"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/categories/iOS" alt="menu.iOS" title="menu.iOS">menu.iOS</a></li><li class="nav__item"><a href="/categories/Python" alt="menu.python" title="menu.python">menu.python</a></li><li class="nav__item"><a href="/GirlsPhotos" alt="menu.小姐姐" title="menu.小姐姐">menu.小姐姐</a></li><li class="nav__item"><a href="/archives" alt="menu.时间轴" title="menu.时间轴">menu.时间轴</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="/img/default_header.jpg" alt="iOS 中的各种锁"></div><header class="post__info"><h1 class="post__title">iOS 中的各种锁</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="https://www.github.com/anru1314">Anrue</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2018-11-09</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/锁/">锁</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-eye"></i><ul class="mark__list clearfix"><li id="busuanzi_container_page_pv" class="mark__item"><span id="busuanzi_value_page_pv"></span>次</li></ul></div></div></header><div class="post__content"><p><img src="/images/iOS/2018-11-09-iOS-中的各种锁/topImg.png" alt="图片"></p><hr><ul><li>常用锁性能比较：<br><img src="/images/iOS/2018-11-09-iOS-中的各种锁/15414020684047.jpg" alt="图片"></li></ul><blockquote><p><strong>互斥锁(Mutex)</strong>: 是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。它的<strong>原子性</strong>确保了如果一个线程锁定了一个互斥量，将没有其他线程在同一时间可以锁定这个互斥量。它的<strong>唯一性</strong>确保了只有它解锁了这个互斥量，其他线程才可以对其进行锁定。当一个线程锁定一个资源的时候，其他对该资源进行访问的线程将会被挂起，直到该线程解锁了互斥量，其他线程才会被唤醒，进一步才能锁定该资源进行操作。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</p></blockquote><blockquote><p><strong>同步锁</strong>: 是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。也就是说使用信号量可以使多个线程有序访问某个资源。</p></blockquote><blockquote><p><strong>自旋锁</strong>: 自旋锁，和互斥锁类似，都是为了保证线程安全的锁。自旋锁当一个线程获得锁之后，其他线程将会一直循环在那里尝试执行，查看是否该锁被释放。CPU被浪费，执行速度快。所以，此锁比较适用于锁的持有者保存时间较短的情况下。</p></blockquote><blockquote><p><strong>递归锁</strong>: 可以被一个线程多次获得，而不会引起死锁。它记录了成功获得锁的次数，每一次成功的获得锁，必须有一个配套的释放锁和其对应，这样才不会引起死锁。只有当所有的锁被释放之后，其他线程才可以获得锁。</p></blockquote><blockquote><p><strong>显示锁</strong>: 较<code>synchronized</code>内置在代码里面的隐式锁。显示锁需要我们获取锁，释放锁。锁对象越小越好</p></blockquote><h3 id="synchronized-关键字加锁"><a href="#synchronized-关键字加锁" class="headerlink" title="@synchronized 关键字加锁"></a>@synchronized 关键字加锁</h3><p><a href="#">MrPeak杂货铺</a>里面有篇很好的文章：<a href="http://mrpeak.cn/blog/synchronized/" target="_blank" rel="noopener">正确使用多线程同步锁@synchronized()</a></p><p>当我在<a href="https://github.com/anru1314/runtime">源码</a>全局搜索<code>synchronized</code>的时候，很容易就找到了(当然也在Xcode中选择菜单<code>Product-&gt;Perform Action-&gt;Assemble &quot;xxx.m</code>“,看到<code>_objc_sync_enter</code>、<code>_objc_sync_exit</code>这2个函数)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// Begin synchronizing on &apos;obj&apos;. </span><br><span class="line">// Allocates recursive mutex associated with &apos;obj&apos; if needed.</span><br><span class="line">// Returns OBJC_SYNC_SUCCESS once lock is acquired.  </span><br><span class="line">int objc_sync_enter(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    int result = OBJC_SYNC_SUCCESS;</span><br><span class="line"></span><br><span class="line">    if (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, ACQUIRE);</span><br><span class="line">        assert(data);</span><br><span class="line">        data-&gt;mutex.lock();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // @synchronized(nil) does nothing</span><br><span class="line">        if (DebugNilSync) &#123;</span><br><span class="line">            _objc_inform(&quot;NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        objc_sync_nil();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// End synchronizing on &apos;obj&apos;. </span><br><span class="line">// Returns OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR</span><br><span class="line">int objc_sync_exit(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    int result = OBJC_SYNC_SUCCESS;</span><br><span class="line">    </span><br><span class="line">    if (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, RELEASE); </span><br><span class="line">        if (!data) &#123;</span><br><span class="line">            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            bool okay = data-&gt;mutex.tryUnlock();</span><br><span class="line">            if (!okay) &#123;</span><br><span class="line">                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // @synchronized(nil) does nothing</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感兴趣的可以下载源码看看</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><strong><code>synchronized</code>中传入的<code>object</code>的内存地址，被用作key，通过<code>hash map</code>对应的一个系统维护的递归锁<code>mutex</code>来做同步。</strong><br>所以：</p><ul><li>不管是传入什么类型的object，只要是有内存地址，就能启动同步代码块的效果。</li><li><p><code>synchronized</code>内部采用递归锁<code>mutex</code>（底层应该还是使用的<code>pthread_mutex_t</code>），我们可以嵌套使用，不会造成死锁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@synchronized (obj) &#123;</span><br><span class="line">    NSLog(@&quot;1st sync&quot;);</span><br><span class="line">    @synchronized (obj) &#123;</span><br><span class="line">        NSLog(@&quot;2nd sync&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我们可以使用<code>pthread_mutex_t</code>递归锁来代替<code>synchronized</code>：<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+(id)fooFerBar:(id)bar &#123;</span><br><span class="line">@synchronized(self) &#123;</span><br><span class="line">   static NSDictionary *foo = nil;</span><br><span class="line">   if (!foo) foo = [NSDictionary dictionaryWithObjects:...];</span><br><span class="line">&#125;</span><br><span class="line">   return [foo objectWithKey:bar];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>上面的例子，<strong>用pthread_mutex_t来代替，虽然很难看，但是性能好很多</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">+(id)fooFerBar:(id)bar &#123;</span><br><span class="line">   static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">   if (pthread_mutex_lock(&amp;mtx)) &#123;</span><br><span class="line">      printf(&quot;lock failed sigh...&quot;);</span><br><span class="line">      exit(-1);</span><br><span class="line">&#125;</span><br><span class="line">   static NSDictionary *foo = nil;</span><br><span class="line">   if (!foo) foo = [NSDictionary dictionaryWithObjects:...];</span><br><span class="line">   if (pthread_mutex_unlock(&amp;mtx) != 0)) &#123;</span><br><span class="line">      printf(&quot;unlock failed sigh...&quot;);</span><br><span class="line">      exit(-1);</span><br><span class="line">&#125;</span><br><span class="line">   return [foo objectWithKey:bar];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@synchronized(nil)</code>不起任何作用<br>从源码我们可以看到<code>synchronized</code>传入对象为空时，什么都没有做</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>MrPeak大神也指出了几点注意的地方：</p><ul><li><p>使用<code>@synchronized(self)</code>带来的死锁</p></li><li><p>精准的粒度控制</p></li></ul><p><code>synchronized</code> 是互斥锁，是同类中最方便的隐式锁，性能虽然较差，但是我们也应该把握粒度。</p><p>从源码我们可以知道，@synchronized(obj) 中的 obj 通过 hash 算法存储到了一份手动维护的 cache 中，cache 的 key 使用的是 obj 的内存地址。hash 算法恰能以 O(1)的时间复杂度，以 obj 为 key 取出对应的锁。即内容与位置之间的快速映射关系，也即是一个地址对应一个锁；@synchronized 使用多了之后，快速的通过 obj 取出对应的锁，能够达到优化多线程的性能的作用。</p><p>🔞 <strong>错误做法</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@synchronized (sharedToken) &#123;</span><br><span class="line">    [arrA addObject:obj];</span><br><span class="line">&#125;</span><br><span class="line">@synchronized (sharedToken) &#123;</span><br><span class="line">    [arrB addObject:obj];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>❗️❗️❗️ <strong>任何时间都只有一个线程在临界区内执行。</strong></p><p>我们可以这么理解:一栋大楼,里面有很多小房间,每个房间里面装是不同”代码”。现在我们只想一次让一个人进去房间,办法就是在外面”加锁”。”锁”的范围可以加在房间上，也可以加在整栋楼的大门上。而现在这种情况就好比是加在整栋楼的大门上,一旦进去有人进入A房间,即使有人想要进去B房间也会被”锁”在整栋的大门外(<strong>阻塞</strong>)。(整栋楼就是临界区)。所以最好的办法就是进行<strong>粒度控制</strong>,锁加载每个”房间门”的外面。获取锁的对象”范围越大”,临界区”越广”。<br>所以如果是在不同的线程，另一个线程会造成阻塞。</p><p>✅ <strong>正确做法</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@synchronized (tokenA) &#123;</span><br><span class="line">    [arrA addObject:obj];</span><br><span class="line">&#125;</span><br><span class="line">@synchronized (tokenB) &#123;</span><br><span class="line">    [arrB addObject:obj];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li>注意内部的函数调用<br>{}内部有其他隐蔽的函数调用。比如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@synchronized (tokenA) &#123;</span><br><span class="line">    [arrA addObject:obj];</span><br><span class="line">    [self doSomethingWithA:arrA];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doSomethingWithA内部可能又调用了其他函数，维护doSomethingWithA的工程师可能并没有意识到自己是被锁同步的，由此层层叠叠可能引入更多的函数调用，代码就莫名其妙的越来越慢了，感觉锁的性能差，其实是我们没用好。</p><h3 id="NSLock-h-里面的4中锁"><a href="#NSLock-h-里面的4中锁" class="headerlink" title="NSLock.h 里面的4中锁"></a>NSLock.h 里面的4中锁</h3><p>在【高性能iOS应用开发】书中提到：锁是进入临界区的基础构件。<code>atomic</code>属性和<code>@synchronized</code>块是为了实现边界实用的高级别抽象。</p><p>在<code>NSLock.h</code>里面一共存在4把锁，都遵守<code>NSLocking</code>协议，分别是获取锁，释放锁。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@protocol NSLocking</span><br><span class="line"></span><br><span class="line">- (void)lock;</span><br><span class="line">- (void)unlock;</span><br></pre></td></tr></table></figure><p></p><h4 id="NSLock-对象锁"><a href="#NSLock-对象锁" class="headerlink" title="NSLock 对象锁"></a>NSLock 对象锁</h4><p>NSLock 是一种低级别的锁。一旦获取了锁，执行则进入临界区，且不会允许超过一个线程并行执行。释放锁则标记这临界区的结束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// _cpuUsageLock是一个私有字段，也可以是一个属性</span><br><span class="line">- (NSArray *)cpuUsagePerProcessor &#123;</span><br><span class="line">    // 初始化锁</span><br><span class="line">    _cpuUsageLock = [[NSLock alloc] init];</span><br><span class="line">    [_cpuUsageLock lock];</span><br><span class="line">    // TODO: 线程安全代码</span><br><span class="line">    [_cpuUsageLock unlock];//释放锁标记着临界区的结束。其他线程就可以获取锁了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>NSLock 必须在锁定的线程中进行解锁。</strong></p><p><strong>在调用<code>lock</code>之前，<code>NSLock</code>必须先调用<code>unlock</code></strong>。所以如果连续锁定两次，已经获取了锁，再去获取锁，线程会因为等待锁的释放而进入睡眠状态，因此就不可能再释放锁，则会造成死锁问题。如果想要达到递归锁的效果，可以使用<code>NSRecursiveLock</code>。</p><h4 id="NSRecursiveLock-递归锁"><a href="#NSRecursiveLock-递归锁" class="headerlink" title="NSRecursiveLock 递归锁"></a>NSRecursiveLock 递归锁</h4><p><code>NSRecursiveLock</code>允许在被解锁前锁定多次。如果解锁的次数与锁定的次数相匹配，则认为锁释放，其他线程可以获取锁。当类中有多个方法使用同一个锁进行同步，且其中一个方法调用另一个方法时，<code>NSRecursiveLock</code>非常好用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _lock = [NSRecursiveLock new];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)threadSafeMethod1</span><br><span class="line">&#123;</span><br><span class="line">    [_lock lock];</span><br><span class="line">    //threadSafe code</span><br><span class="line">    [self threadSafeMethod2];</span><br><span class="line">    [_lock unlock];</span><br><span class="line">&#125;</span><br><span class="line">- (void)threadSafeMethod2</span><br><span class="line">&#123;</span><br><span class="line">    [_lock lock];</span><br><span class="line">//    threadSafe code</span><br><span class="line">    [_lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个锁定操作都有一个相应的解锁操作与之匹配。</p><h4 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h4><p><code>NSCondition</code> 可以协调线程之间的执行。一个线程会等待释放锁的变量条件，另一个线程会通知条件变量释放锁，并唤醒等待中的线程。<br><code>NSCondition</code> 可以原子性地释放锁，从而使得其他等待的线程可以获取锁，而初始的线程继续等待。</p><ul><li>举个典型的例子：<br>消费者取得锁，取产品，如果没有，则线程会wait，这时会释放锁，直到有线程唤醒它去消费产品；<br>生产者制造产品，首先也是要取得锁，然后生产，再发signal，这样可唤醒wait的消费者，最后释放锁。</li><li><code>broadcast</code>和 <code>signal</code>的区别：<br>消费者和生产者都有可能会等待，所以<code>broadcast</code>是唤醒所有线程，而signal 只会通知一个等待的线程</li><li>值得注意的是：<code>lock</code>和<code>unlock</code>是成对出现的。</li><li>RAC里面也有一个很好理解的示例： <code>RACCommand</code> 被执行<code>execute</code>的时候底层调用了<code>- (id)first</code>，最终执行代码如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- (id)firstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error &#123;</span><br><span class="line">	NSCondition *condition = [[NSCondition alloc] init];</span><br><span class="line">	condition.name = [NSString stringWithFormat:@&quot;[%@] -firstOrDefault: %@ success:error:&quot;, self.name, defaultValue];</span><br><span class="line"></span><br><span class="line">	__block id value = defaultValue;</span><br><span class="line">	__block BOOL done = NO;</span><br><span class="line"></span><br><span class="line">	// Ensures that we don&apos;t pass values across thread boundaries by reference.</span><br><span class="line">	__block NSError *localError;</span><br><span class="line">	__block BOOL localSuccess;</span><br><span class="line"></span><br><span class="line">	[[self take:1] subscribeNext:^(id x) &#123;</span><br><span class="line">		[condition lock];</span><br><span class="line"></span><br><span class="line">		value = x;</span><br><span class="line">		localSuccess = YES;</span><br><span class="line"></span><br><span class="line">		done = YES;</span><br><span class="line">		[condition broadcast];</span><br><span class="line">		[condition unlock];</span><br><span class="line">	&#125; error:^(NSError *e) &#123;</span><br><span class="line">		[condition lock];</span><br><span class="line"></span><br><span class="line">		if (!done) &#123;</span><br><span class="line">			localSuccess = NO;</span><br><span class="line">			localError = e;</span><br><span class="line">			done = YES;</span><br><span class="line">			[condition broadcast];</span><br><span class="line">		&#125;</span><br><span class="line">		[condition unlock];</span><br><span class="line">	&#125; completed:^&#123;</span><br><span class="line">		[condition lock];</span><br><span class="line">		localSuccess = YES;</span><br><span class="line">		done = YES;</span><br><span class="line">		[condition broadcast];</span><br><span class="line">		[condition unlock];</span><br><span class="line">	&#125;];</span><br><span class="line"></span><br><span class="line">	[condition lock];</span><br><span class="line">	while (!done) &#123;</span><br><span class="line">		[condition wait];</span><br><span class="line">	&#125;</span><br><span class="line">	if (success != NULL) *success = localSuccess;</span><br><span class="line">	if (error != NULL) *error = localError;</span><br><span class="line">	[condition unlock];</span><br><span class="line">	return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NSConditionLock-条件锁"><a href="#NSConditionLock-条件锁" class="headerlink" title="NSConditionLock 条件锁"></a>NSConditionLock 条件锁</h4><p><code>NSCondition</code> 和 <code>NSConditionLock</code>很像，同样的生产者消费者模型，我们可以使用 NSConditionLock 。当生产者执行执行的时候，消费者可以通过特定的条件获得锁，当生产者完成执行的时候，它将解锁该锁，然后把锁的条件设置成唤醒消费者线程的条件。</p><p>关于<code>NSConditionLock</code>这篇<a href="http://www.cocoachina.com/ios/20161129/18216.html" target="_blank" rel="noopener">文章</a>讲的很好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 用于condition等于特定值的时候获取锁，会阻塞当前线程。</span><br><span class="line">- (void)lockWhenCondition:(NSInteger)condition;</span><br><span class="line"></span><br><span class="line">// 尝试获取锁，获取锁失败时返回NO，try开头的方法会理解解锁。</span><br><span class="line">- (BOOL)tryLock;</span><br><span class="line">- (BOOL)tryLockWhenCondition:(NSInteger)condition;</span><br><span class="line"></span><br><span class="line">// 指定条件时解锁，每次解锁会导致内部的condition值改变为指定的值，同时唤醒其它阻塞的线程检测这里的condition是否满足条件，因此NSConditionLock相对于NSCondition效率更低。</span><br><span class="line">- (void)unlockWithCondition:(NSInteger)condition;</span><br><span class="line"></span><br><span class="line">// 指定条件获取锁，会阻塞当前线程。</span><br><span class="line">- (BOOL)lockBeforeDate:(NSDate *)limit;</span><br><span class="line">- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;</span><br></pre></td></tr></table></figure><h3 id="pthread-mutex-互斥锁（C语言）"><a href="#pthread-mutex-互斥锁（C语言）" class="headerlink" title="pthread_mutex 互斥锁（C语言）"></a>pthread_mutex 互斥锁（C语言）</h3><p><code>pthread</code> 表示 <code>POSIX thread</code>，定义了一组跨平台的线程相关的 API，<code>pthread_mutex</code>表示互斥锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> Mutex type attributes</span><br><span class="line">*/</span><br><span class="line">// 缺省类型，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后先进先出原则获得锁。</span><br><span class="line">#define PTHREAD_MUTEX_NORMAL        0</span><br><span class="line">// 检错锁，如果同一个线程请求同一个锁，则返回 EDEADLK，否则与普通锁类型动作相同。这样就保证当不允许多次加锁时不会出现嵌套情况下的死锁。</span><br><span class="line">#define PTHREAD_MUTEX_ERRORCHECK    1</span><br><span class="line">// 递归锁，允许同一个线程对同一个锁成功获得多次，并通过多次 unlock 解锁。</span><br><span class="line">#define PTHREAD_MUTEX_RECURSIVE     2</span><br><span class="line">// 适应锁，动作最简单的锁类型，仅等待解锁后重新竞争，没有等待队列。</span><br><span class="line">#define PTHREAD_MUTEX_DEFAULT	      PTHREAD_MUTEX_NORMAL</span><br><span class="line"></span><br><span class="line">pthread_mutexattr_t attr;  </span><br><span class="line">pthread_mutexattr_init(&amp;attr);  </span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_NORMAL); </span><br><span class="line"></span><br><span class="line">pthread_mutex_t _lock</span><br><span class="line">// 第二个参数是pthread_mutexattr_t的指针，一般填NULL(即为缺省值)，也可以填&amp;attr</span><br><span class="line">pthread_mutex_init(&amp;_lock, NULL); //创建锁</span><br><span class="line">// 返回0即为成功，失败返回错误码</span><br><span class="line">pthread_mutex_trylock(&amp;_lock) // 尝试获取锁</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;_lock); // 获取锁</span><br><span class="line">// 线程安全代码</span><br><span class="line">pthread_mutex_unlock(&amp;_lock) // 释放锁</span><br><span class="line"></span><br><span class="line">// 一般在delloc方法里面销毁</span><br><span class="line">pthread_mutex_destroy(&amp;_lock); // 销毁锁</span><br><span class="line">pthread_mutexattr_destroy(&amp;attr);</span><br></pre></td></tr></table></figure><p><code>NSLock</code>内部封装了一个 <code>pthread_mutex</code>，属性为 <code>PTHREAD_MUTEX_ERRORCHECK</code>。所以会存在跟<code>NSLock</code>一样的死锁问题。想要在临界区内再获取锁，做好将属性设置为<code>PTHREAD_MUTEX_RECURSIVE</code></p><h3 id="dispatch-semaphore-信号量实现加锁（GCD）"><a href="#dispatch-semaphore-信号量实现加锁（GCD）" class="headerlink" title="dispatch_semaphore 信号量实现加锁（GCD）"></a>dispatch_semaphore 信号量实现加锁（GCD）</h3><p>信号量实现的显示锁</p><p>dispatch_semaphore 是 GCD 用来同步的一种方式，与他相关的共有三个函数，分别是</p><blockquote><ul><li>dispatch_semaphore_create：定义信号量</li><li>dispatch_semaphore_signal：使信号量+1</li><li>dispatch_semaphore_wait：使信号量-1</li></ul></blockquote><blockquote><p>当信号量为 0 时，就会做等待处理，这时其他线程如果访问的话就会让其等待。所以如果信号量在最开始的的时候被设置为1，那么就可以实现“锁”的功能：<br>执行某段代码之前，执行dispatch_semaphore_wait 函数，让信号量减 1 变为 0，执行这段代码。</p></blockquote><blockquote><p>此时如果其他线程过来访问这段代码，就要让其等待。<br>当这段代码在当前线程结束以后，执行 dispatch_semaphore_signal 函数，令信号量再次 加1，那么如果有正在等待的线程就可以访问了。</p></blockquote><p>需要注意的是：如果有多个线程等待，那么后来信号量恢复以后访问的顺序就是线程遇到 dispatch_semaphore_wait 的顺序。</p><p>这也就是信号量和互斥锁的一个区别：互斥量用于线程的互斥，信号线用于线程的同步。</p><p>从首页的图可以看出，自旋锁和信号量加解锁耗时分别排行一二。<a href="http://www.codeceo.com/article/ios-lock.html" target="_blank" rel="noopener">深入理解 iOS 开发中的锁</a>的作者强调指出：<strong>加解锁耗时不能准确反应出锁的效率(比如时间片切换就无法发生)，它只能从一定程度上衡量锁的实现复杂程度。</strong></p><ul><li>SDImageCache 中的例子</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 内存缓存 weakCache  -- NSMapTable</span><br><span class="line">#define LOCK(lock) dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</span><br><span class="line">#define UNLOCK(lock) dispatch_semaphore_signal(lock);</span><br><span class="line"></span><br><span class="line">self.weakCacheLock = dispatch_semaphore_create(1);</span><br><span class="line"></span><br><span class="line">LOCK(self.weakCacheLock);</span><br><span class="line">[self.weakCache setObject:obj forKey:key];</span><br><span class="line">UNLOCK(self.weakCacheLock);</span><br></pre></td></tr></table></figure><h3 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h3><p>关于<code>OSSpinLock</code>自旋锁，可以看大神<a href="https://blog.ibireme.com" target="_blank" rel="noopener">YY</a>的博客<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的OSSpinLock</a></p><p>按照YY大神的描述：<br>操作系统在管理普通线程时，采用的是时间片轮转算法。每个线程会被分配一段时间片(quantum)，通常在 10-100 毫秒左右。当线程用完属于自己的时间片以后，就会被操作系统挂起，放入等待队列中，直到下一次被分配时间片。这样的算法会存在潜在的优先级反转问题。<br>当低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，它会处于 spin lock 的忙等状态从而占用大量 CPU（占着cpu，却获取不到锁）。此时低优先级线程无法与高优先级线程争夺 CPU 时间，从而导致任务迟迟完不成、无法释放 lock。<br>除非开发者能保证访问锁的线程全部都处于同一优先级。</p><p>当一个进程正处在某临界区内，任何试图进入其临界区的进程都必须进入代码连续循环，陷入忙等状态。</p><h3 id="os-unfair-lock"><a href="#os-unfair-lock" class="headerlink" title="os_unfair_lock"></a>os_unfair_lock</h3><p>在 iOS 10/macOS 10.12 发布时，苹果提供了新的 <code>os_unfair_lock</code> 作为 <code>OSSpinLock</code> 的替代，并且将 <code>OSSpinLock</code> 标记为了 <code>Deprecated</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">os_unfair_lock_t unfairLock;</span><br><span class="line">unfairLock = &amp;(OS_UNFAIR_LOCK_INIT);</span><br><span class="line">os_unfair_lock_lock(unfairLock);</span><br><span class="line">os_unfair_lock_unlock(unfairLock);</span><br></pre></td></tr></table></figure><h3 id="pthread-rwlock"><a href="#pthread-rwlock" class="headerlink" title="pthread_rwlock"></a>pthread_rwlock</h3><p>从名字就可以看出跟读写相关的锁–读写锁</p><ul><li>当读写锁被一个线程以读模式占用的时候，写操作的其他线程会被阻塞，读操作的其他线程还可以继续进行。</li><li>当读写锁被一个线程以写模式占用的时候，写操作的其他线程会被阻塞，读操作的其他线程也被阻塞。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 初始化锁</span><br><span class="line">pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER</span><br><span class="line"></span><br><span class="line">pthread_rwlock_rdlock(&amp;rwlock);//加读锁</span><br><span class="line">// 临界区</span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);//解锁</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pthread_rwlock_wrlock(&amp;rwlock);//加写锁</span><br><span class="line">// 临界区</span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);//解锁</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>高性能的时候就用<code>dispatch_semaphore</code>或<code>pthread_mutex</code>。iOS10以上可以用<code>os_unfair_lock</code>。</li><li>想简单方便就用<code>@synchronized</code>。</li></ul><h3 id="优秀博客"><a href="#优秀博客" class="headerlink" title="优秀博客"></a>优秀博客</h3><ul><li><a href="http://www.codeceo.com/article/ios-lock.html" target="_blank" rel="noopener">深入理解 iOS 开发中的锁</a></li><li><a href="http://www.cocoachina.com/ios/20161129/18216.html" target="_blank" rel="noopener">iOS 中的各种锁</a></li><li><a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的OSSpinLock</a></li></ul><div class="post-announce">感谢您的阅读，本文由 <a href="https://github.com/anru1314">Anrue</a> 版权所有。如若转载，请注明出处：Anrue（<a href="https://github.com/anru1314/2018/11/09/iOS/2018-11-09-iOS-中的各种锁/">https://github.com/anru1314/2018/11/09/iOS/2018-11-09-iOS-中的各种锁/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2018/10/31/iOS/2018-10-31-组件化中遇到的问题-篇章一/" title="组件化中遇到的问题--篇章一"><i class="iconfont icon-prev"></i>组件化中遇到的问题--篇章一</a></div><div class="post__prev post__prev--right"></div></div></div></article><div id="comment-container"></div></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">这般花花草草由人恋，酸酸楚楚随人愿，便生生死死无人怨！</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/iOS/">iOS</a><span class="block-list-count">4</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Python/">Python</a><span class="block-list-count">2</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2018/11/09/iOS/2018-11-09-iOS-中的各种锁/" title="iOS 中的各种锁"><div class="item__cover"><img src="/img/default_header.jpg" alt="iOS 中的各种锁"></div><div class="item__info"><h3 class="item__title">iOS 中的各种锁</h3><span class="item__text">2018-11-09</span></div></a></li><li class="latest-post-item"><a href="/2018/10/31/iOS/2018-10-31-组件化中遇到的问题-篇章一/" title="组件化中遇到的问题--篇章一"><div class="item__cover"><img src="/img/default_header.jpg" alt="组件化中遇到的问题--篇章一"></div><div class="item__info"><h3 class="item__title">组件化中遇到的问题--篇章一</h3><span class="item__text">2018-10-31</span></div></a></li><li class="latest-post-item"><a href="/2018/10/10/python/2018-10-10-常见图片格式/" title="常见图片格式"><div class="item__cover"><img src="/img/default_header.jpg" alt="常见图片格式"></div><div class="item__info"><h3 class="item__title">常见图片格式</h3><span class="item__text">2018-10-10</span></div></a></li><li class="latest-post-item"><a href="/2018/10/09/python/2018-10-09-MySql笔记/" title="MySql笔记"><div class="item__cover"><img src="/img/default_header.jpg" alt="MySql笔记"></div><div class="item__info"><h3 class="item__title">MySql笔记</h3><span class="item__text">2018-10-09</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/MySql/">MySql</a></li><li class="tag-item"><a class="tag-link" href="/tags/图片/">图片</a></li><li class="tag-item"><a class="tag-link" href="/tags/定时器/">定时器</a></li><li class="tag-item"><a class="tag-link" href="/tags/组件化/">组件化</a></li><li class="tag-item"><a class="tag-link" href="/tags/自定义转场动画/">自定义转场动画</a></li><li class="tag-item"><a class="tag-link" href="/tags/锁/">锁</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">本站是基于 Hexo 搭建的静态资源博客，主要用于分享日常学习、生活及工作的一些心得总结，欢迎点击右下角订阅 rss。</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>ShenZhen, Guangdong Province, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>anrugood@outlook.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="/img/iconTimg.jpg" alt="logo" title="Anrue"></div><div class="footer-top__item"><h3 class="item__title">友情链接</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://southpeak.github.io/" title="南峰子" target="_blank">南峰子的技术博客</a></li><li class="list-item"><a href="https://www.kwen.work/" title="Kevin" target="_blank">Kevin‘s blod</a></li></ul></div></div><div class="footer-top__item"><h3 class="item__title">构建工具</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://hexo.io/" title="Blog Framework" target="_blank">Hexo</a></li><li class="list-item"><a href="https://developer.apple.com/xcode/" title="iOS" target="_blank">Xcode</a></li><li class="list-item"><a href="https://www.python.org/" title="Python 官网" target="_blank">Python</a></li></ul></div></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/anru1314" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:anrugood@outlook.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li><li class="social-network__item"><a href="/atom.xml" target="_blank" title="rss"><i class="iconfont icon-rss"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="/js/md5.min.js"></script><script>var tags=["锁"],gitalk=new Gitalk({clientID:"59f35a92c3aaa2497cde",clientSecret:"602060680fba1dd4c13b187f933b3c715f88001c",repo:"xiaojiejie",owner:"anru1314",admin:["anru1314"],labels:tags,id:new Date(1541749906e3).getTime()>new Date("2018-02-15").getTime()?md5(location.href):location.href});gitalk.render("comment-container")</script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>