<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><title>runtime 运行时--篇章二 | Anrue Blog</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="[object Object]"><meta name="designer" content="minfive"><meta name="keywords" content="iOS, Pyton, Anrue, Anrue blog, iOS博客, 程序员"><meta name="description" content="这般花花草草由人恋，酸酸楚楚随人愿，便生生死死无人怨！"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="https://github.com/anru1314/2018/12/01/iOS/runtime-运行时-篇章二/index.html"><link rel="icon" type="image/png" href="/img/favicon.png" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="Anrue"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-129291851-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-129291851-1")</script><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart=""><div id="page-loading" class="page page-loading" style="background-image:url(http://oo12ugek5.bkt.clouddn.com/blog/images/loader.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="Anrue" alt="Anrue"><img src="/img/logo.png" alt="Anrue"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="HOME" title="HOME">HOME</a></li><li class="nav__item"><a href="/categories/iOS" alt="iOS" title="iOS">iOS</a></li><li class="nav__item"><a href="/categories/Python" alt="Python" title="Python">Python</a></li><li class="nav__item"><a href="/GirlsPhotos" alt="小姐姐" title="小姐姐">小姐姐</a></li><li class="nav__item"><a href="/archives" alt="时间轴" title="时间轴">时间轴</a></li><li class="nav__item"><a href="/about" alt="ABOUT" title="ABOUT">ABOUT</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="/images/iOS/2018-12-01-runtime运行时/topImg02.png" alt="runtime 运行时--篇章二"></div><header class="post__info"><h1 class="post__title">runtime 运行时--篇章二</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="https://www.github.com/anru1314">Anrue</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2018-12-01</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/runtime/">Runtime</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-eye"></i><ul class="mark__list clearfix"><li id="busuanzi_container_page_pv" class="mark__item"><span id="busuanzi_value_page_pv"></span>&nbsp<span>次</span></li></ul></div></div></header><div class="post__content"><p>运行时系统 – 篇章二</p><p>[TOC]</p><p>这一章讲，运行时系统的结构。<br><code>runtime</code>开源代码可以点击这里<a href="https://github.com/anru1314/runtime.git">下载</a>，已经编译好了，下载即可直接运行。</p><h3 id="运行时的组成部分"><a href="#运行时的组成部分" class="headerlink" title="运行时的组成部分"></a>运行时的组成部分</h3><p>OC运行时系统由2个主要部分构成：编译器和运行时系统库</p><h4 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h4><p>像C语言标准函数库为C语言程序提供标准API和实现代码一样。运行时系统库也会为OC面向对象的特性提供标准API和实现代码。这种库与所有OC程序链接。</p><p>编译器的作用是接受输入的源代码，生成使用了运行时系统库的代码，从而得到合法、可执行的OC程序。</p><p>不管是<code>OC</code>还是<code>Swift</code>，都是采用Clang作为编译器前端，<code>LLVM(Low level vritual machine)</code>作为编译器后端。</p><ul><li><p>编译器前端<br>编译器前端的任务是进行：语法分析，语义分析，生成中间代码(intermediate representation )。在这个过程中，会进行类型检查，如果发现错误或者警告会标注出来在哪一行。</p></li><li><p>编译器后端<br>编译器后端会进行机器无关的代码优化，生成机器语言，并且进行机器相关的代码优化。</p></li></ul><p>且看编译器如何为OC的类和对象生成可执行的代码，以及如何实现对象消息：</p><h5 id="生成对象消息传递代码"><a href="#生成对象消息传递代码" class="headerlink" title="生成对象消息传递代码"></a>生成对象消息传递代码</h5><p>当编译器解析对象消息（发送消息的表达式）时，如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[接收器  消息]</span><br></pre></td></tr></table></figure><p></p><p>它会<strong>生成并调用</strong>运行时系统库中函数<code>objc_msgSend()</code>的代码。该函数将接收器、选择器、消息传递的参数 作为输入参数。<br>编译器会将所有的消息传递表达式转换为运行时系统函数代码，并提供相应的参数。而每条消息都是以动态方式处理的，所以又回到了之前所讲的：接收器的类型和方法实现代码都是在运行时决定的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector)</span><br></pre></td></tr></table></figure><ul><li>首先它找到selector对应的方法实现。因为同一个方法可能在不同的类中有不同的实现，所以我们需要依赖于接收者的类来找到的确切的实现。</li><li>它调用方法实现，并将接收者对象及方法的所有参数传给它。</li><li>最后，它将实现返回的值作为它自己的返回值。</li></ul><p>对于源代码中的类和对象来说，编译器创建了执行对象消息操作所需的数据结构。</p><h5 id="生成类和对象代码"><a href="#生成类和对象代码" class="headerlink" title="生成类和对象代码"></a>生成类和对象代码</h5><p>当编译器解析含有类定义和对象的OC源代码时，会生成相应的运行时数据结构。</p><p>OC的类与运行时系统库中的<code>Class</code>数据结构对应。在<code>objc.h</code>中，<code>Class</code>是指向<code>objc_class</code>类型的结构体指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// An opaque type that represents an Objective-C class. </span><br><span class="line">// 指向带有objc_class标识符的不透明数据类型的指针。</span><br><span class="line">typedef struct objc_class *Class;</span><br><span class="line"></span><br><span class="line">struct objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    const char *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><p>不透明数据类型是一种接口定义不完整的C语言结构类型。提供了一种数据隐藏模式，其变量只能由专门为它们定义的函数访问。使用运行时系统库中的函数就可以访问<code>Class</code>(即<code>objc_class</code>)数据类型</p><p>同样，OC对象也拥有，编译器创建的运行时数据类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct objc_object &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">    // 后面还有实例变量</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们创建对象时，系统会为<code>objc_object</code>类型的结构体分配内存，这种数据由isa指针后面跟实例变量的数据构成。</p><p><code>objc_object</code>类型也有<code>Class</code>类型的isa指针（也是就是说每个对象都有一个isa指针，指向类对象）。所有的OC对象和类都是以isa指针开头，isa指针是指向<code>objc_class</code>结构体的指针。</p><p>让我们来看看id数据类型的定义：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 在objc.h中</span><br><span class="line">typedef struct objc_object *id;</span><br><span class="line">// 我们可以理解成这样</span><br><span class="line">typedef struct objc_object &#123;</span><br><span class="line">    Class _Nonnull isa;</span><br><span class="line">&#125; *id;</span><br></pre></td></tr></table></figure><p></p><p>显而易见，<code>id</code> 就是指向<code>objc_object</code>结构体的指针。</p><h5 id="查看运行时系统的数据结构"><a href="#查看运行时系统的数据结构" class="headerlink" title="查看运行时系统的数据结构"></a>查看运行时系统的数据结构</h5><p>OC 对象运行时会转化为<code>objc_object</code>类型的结构体，类会转化为<code>objc_class</code>的结构体。下面我们通过OC代码来观察一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface ANPerson : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    @public</span><br><span class="line">    int age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    // 对象</span><br><span class="line">    ANPerson *person1 = [[ANPerson alloc] init];</span><br><span class="line">    person1-&gt;age = 0xa5a5a5a5;</span><br><span class="line">    </span><br><span class="line">    ANPerson *person2 = [[ANPerson alloc] init];</span><br><span class="line">    person2-&gt;age = 0xc3c3c3c3;</span><br><span class="line">    </span><br><span class="line">    NSInteger person1Size = class_getInstanceSize([person1 class]);</span><br><span class="line">    NSData *person1Data = [NSData dataWithBytes:(__bridge const void *)(person1) length:person1Size];</span><br><span class="line">    NSData *person2Data = [NSData dataWithBytes:(__bridge const void *)(person2) length:person1Size];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;\r\n person1 %p -- %@&quot;,person1, person1Data);</span><br><span class="line">    NSLog(@&quot;\r\n person2 %p -- %@&quot;,person2, person2Data);</span><br><span class="line">    NSLog(@&quot;\r\n person %p&quot;,[person1 class]);</span><br><span class="line">    // 类</span><br><span class="line">    id perClass = objc_getClass(&quot;ANPerson&quot;);</span><br><span class="line">    NSInteger perClassSize = class_getInstanceSize([perClass class]);</span><br><span class="line">    NSData *perClassData = [NSData dataWithBytes:(__bridge const void *)(perClass) length:perClassSize];</span><br><span class="line">    NSLog(@&quot;\r\n person class %@ -- %@&quot;,perClass, perClassData);</span><br><span class="line">    NSLog(@&quot;\r\n person superclass -- %p&quot;, [ANPerson superclass]);</span><br><span class="line">    </span><br><span class="line">    id perMetaClass = objc_getMetaClass(&quot;ANPerson&quot;);</span><br><span class="line">    NSLog(@&quot;\r\n person Mateclass %p&quot;,perMetaClass);</span><br><span class="line"></span><br><span class="line">// 打印结果 </span><br><span class="line"></span><br><span class="line"> person1 0x600000009fd0 -- &lt;40869707 01000000 a5a5a5a5 00000000&gt;</span><br><span class="line"> person2 0x600000009eb0 -- &lt;40869707 01000000 c3c3c3c3 00000000&gt;</span><br><span class="line"></span><br><span class="line"> person 0x107978640</span><br><span class="line"></span><br><span class="line"> person class 0x107978640 -- &lt;18869707 01000000 a83e9208 01000000&gt;</span><br><span class="line"> person superclass -- 0x108923ea8</span><br><span class="line"> person Mateclass 0x107978618</span><br></pre></td></tr></table></figure><ul><li><p>上述代码中，我们将<code>ANPerson</code> 实例化对象<code>person1</code>的内容打印了出来。<code>person1</code>对象的第一个值竟然和类的首地址相同。这样正附和之前介绍的<code>objc_object</code>结构体，<code>objc_object</code>第一个成员就是<code>Class</code> 类型的 <code>isa</code>指针（isa指针是指向该类的内存地址）。而第二个值从打印值来看，正是该对象的实例变量。当编译器解析对象时，就会转化为<code>objc_object</code>的结构体，这一下子是不是很明了了呢？</p></li><li><p>对于类结构，从打印结果来看，是有2个值，第一个值和该类的元类地址一样，<code>objc_class</code>数据结构的第一个成员正是isa指针，是一个指向元类的指针。而另外一个值是该类的父类的首地址（也就是指向该类的父类指针）。</p></li><li><p>你可能发现，打印isa指针的值(40869707 01000000)为啥和类的首地址(0x107978640)不一样？<br>原因：程序在模拟器上运行的，而MAC是以低字节序存储数据的。</p><blockquote><p>内存地址从左到右按照由低到高的顺序<br>低字节序：将低序字节存储在起始地址(地址低位存储值的低位，地址高位存储值的高位)<br>高字节序：将高序字节存储在起始地址(地址低位存储值的高位，地址高位存储值的低位)</p></blockquote><p><code>person1</code>一共占16个字节，<code>isa</code>占8个字节，一个字节2个十六进制，反转过来,(07978640)刚刚好.</p><p>对于整个类的层次结构，我们会更清晰：</p><div align="center"><img align="center" src="/images/iOS/2018-12-01-runtime%20%E8%BF%90%E8%A1%8C%E6%97%B6/15441722937500.jpg" title="类层次结构" width="70%" height="70%"></div></li></ul><h4 id="运行时系统库-runtime"><a href="#运行时系统库-runtime" class="headerlink" title="运行时系统库(runtime)"></a>运行时系统库(runtime)</h4><p>类相关操作函数</p><blockquote><p>对象的类定义 – objc_getClass<br>对象的元类 – objc_getMetaClass<br>类的父类 – class_getSuperclass<br>类的名字 – class_getName<br>类的版本信息 – class_getVersion<br>以字节为单位的类尺寸 – class_getInstanceSize<br>类的实例变量列表 – class_copyIvarList<br>类的方法列表 – class_copyMethodList<br>类的协议列表 – class_copyProtocolList<br>类的属性列表 – class_copyPropertyList</p></blockquote><h5 id="使用runtime创建类"><a href="#使用runtime创建类" class="headerlink" title="使用runtime创建类"></a>使用runtime创建类</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void testAddMethod(id self , IMP _cmd)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;动态添加方法&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)testClass</span><br><span class="line">&#123;</span><br><span class="line">    Class testClass = objc_allocateClassPair([NSObject class], &quot;Test&quot;, 0);</span><br><span class="line">    </span><br><span class="line">    // 指定类的指定方法</span><br><span class="line">    Method des = class_getInstanceMethod([NSObject class], @selector(description));</span><br><span class="line">    // 返回描述方法参数和返回类型的字符串</span><br><span class="line">    const char *types = method_getTypeEncoding(des);</span><br><span class="line">   /**</span><br><span class="line">    向具有给定名称和实现的类添加新方法,会覆盖父类的实现，但对该类以实现的方法无效，想要覆盖当前类的实现，需要使用method_setImplementation</span><br><span class="line">    @ param cls#&gt; 要添加方法的类</span><br><span class="line">    @ param name#&gt; 一个选择器，指定要添加的方法的名称</span><br><span class="line">    @ param imp#&gt; 一个函数，它是新方法的实现。 该函数必须至少有两个参数 -  self和_cmd。</span><br><span class="line">    @ param types#&gt; 一组字符，用于描述方法参数的类型。</span><br><span class="line">    @ return YES如果成功添加方法，否则为NO</span><br><span class="line">    */</span><br><span class="line">    BOOL isSuc = class_addMethod(testClass, @selector(testAddMethod), (IMP)testAddMethod, types);</span><br><span class="line">    if (isSuc) &#123;</span><br><span class="line">        objc_registerClassPair(testClass);</span><br><span class="line">    &#125;</span><br><span class="line">    id obj = [[testClass alloc] init];</span><br><span class="line">    </span><br><span class="line">    ((void(*)(id, SEL))objc_msgSend)(obj, NSSelectorFromString(@&quot;testAddMethod&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="noopener">Type Encodings</a>的介绍，可以上官网查看。</p><h5 id="运行时对象消息的传递"><a href="#运行时对象消息的传递" class="headerlink" title="运行时对象消息的传递"></a>运行时对象消息的传递</h5><p><a href="">篇章一</a>我们已经认识了<code>SEL</code>、<code>IMP</code>,现在再来认识<code>Method</code>。</p><ul><li><code>Method</code>用于表示类定义中的方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *Method; struct </span><br><span class="line"></span><br><span class="line">objc_method &#123; </span><br><span class="line">    SEL method_name OBJC2_UNAVAILABLE; // 方法名 </span><br><span class="line">    char *method_types OBJC2_UNAVAILABLE; </span><br><span class="line">    IMP method_imp OBJC2_UNAVAILABLE; // 方法实现 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>method_name</code> 是一个类型为SEL的变量，是方法的名称。<br><code>method_types</code> 方法参数的数据类型(具体类型可看<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="noopener">Type Encodings</a>)<br><code>method_imp</code> 是一个IMP的变量，在方法调用时提供方法的地址</p></blockquote><p>该结构体中包含一个<code>SEL</code>和<code>IMP</code>，实际上相当于在<code>SEL</code>和<code>IMP</code>之间作了一个映射。一点找到了<code>SEL</code>就找到了<code>IMP</code>.</p><p>为了加速消息的处理，运行时系统不仅缓存(<code>objc_cache</code>)使用过的selector及对应的方法的地址。而且还实现了分发表分派机制。</p><p>每个<code>objc_class</code>(类实例) 都有一个<code>objc_method_list</code>类型的二维指针。而每一个<code>objc_method_list</code>(分发表)的结构体都含有一个<code>objc_method</code>结构体类型的一维数组<code>method_list</code>(指向<code>objc_method</code>数据结构指针的数组)，且只有一个元素。</p><p><code>objc_method_list</code>的定义如下图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct objc_method_list &#123;</span><br><span class="line">    struct objc_method_list *obsolete                        OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    int method_count                                         OBJC2_UNAVAILABLE;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    int space                                                OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">    /* variable length structure */</span><br><span class="line">    struct objc_method method_list[1]                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;                                                           OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure><p>如下图，运行时会先根据<code>selector</code>搜索<strong>类方法缓存</strong>查找方法IMP函数指针。如果没有找到，就会在其类的分发表中寻找<code>selector</code>。并依此，一直沿着类的继承体系到达NSObject类，直到找到为止，它就会将会这个方法(<code>Method</code>)存储到缓存中，方便下次使用。如果还没有找到就会走消息转发流程。</p><p><img align="center" src="/images/iOS/2018-12-01-runtime 运行时/15440606829227/方法查找.png" title="方法查询逻辑"></p><h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><ul><li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html" target="_blank" rel="noopener">Objective-C Runtime Programming Guide</a></li><li><a href="https://southpeak.github.io/2014/10/25/objective-c-runtime-1/" target="_blank" rel="noopener">Objective-C Runtime 运行时之一：类与对象</a></li><li><a href="https://southpeak.github.io/2014/11/03/objective-c-runtime-3/" target="_blank" rel="noopener">Objective-C Runtime 运行时之三：方法与消息</a></li><li><a href="https://www.cnblogs.com/kesalin/archive/2011/08/15/objc_method_base.html" target="_blank" rel="noopener">深入浅出Cocoa之消息</a></li></ul><div class="post-announce">感谢您的阅读，本文由 <a href="https://github.com/anru1314">Anrue</a> 版权所有。如若转载，请注明出处：Anrue（<a href="https://github.com/anru1314/2018/12/01/iOS/runtime-运行时-篇章二/">https://github.com/anru1314/2018/12/01/iOS/runtime-运行时-篇章二/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2018/12/01/iOS/runtime-运行时-篇章一/" title="runtime 运行时--篇章一"><i class="iconfont icon-prev"></i>runtime 运行时--篇章一</a></div><div class="post__prev post__prev--right"></div></div></div></article><div id="comment-container"></div></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">这般花花草草由人恋，酸酸楚楚随人愿，便生生死死无人怨！</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/旅游/">旅游</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/iOS/">iOS</a><span class="block-list-count">6</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Python/">Python</a><span class="block-list-count">2</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2018/12/01/iOS/runtime-运行时-篇章二/" title="runtime 运行时--篇章二"><div class="item__cover"><img src="/images/iOS/2018-12-01-runtime运行时/topImg02.png" alt="runtime 运行时--篇章二"></div><div class="item__info"><h3 class="item__title">runtime 运行时--篇章二</h3><span class="item__text">2018-12-01</span></div></a></li><li class="latest-post-item"><a href="/2018/12/01/iOS/runtime-运行时-篇章一/" title="runtime 运行时--篇章一"><div class="item__cover"><img src="/images/iOS/2018-12-01-runtime运行时/topImg01.png" alt="runtime 运行时--篇章一"></div><div class="item__info"><h3 class="item__title">runtime 运行时--篇章一</h3><span class="item__text">2018-12-01</span></div></a></li><li class="latest-post-item"><a href="/2018/11/09/iOS/2018-11-09-iOS-中的各种锁/" title="不可描述的 iOS 锁事"><div class="item__cover"><img src="/images/iOS/2018-11-09-iOS-中的各种锁/topImg.png" alt="不可描述的 iOS 锁事"></div><div class="item__info"><h3 class="item__title">不可描述的 iOS 锁事</h3><span class="item__text">2018-11-09</span></div></a></li><li class="latest-post-item"><a href="/2018/10/31/iOS/2018-10-31-组件化中遇到的问题-篇章一/" title="组件化中遇到的问题--篇章一"><div class="item__cover"><img src="/images/iOS/2018-10-31-组件化中遇到的问题-篇章一/topImg.png" alt="组件化中遇到的问题--篇章一"></div><div class="item__info"><h3 class="item__title">组件化中遇到的问题--篇章一</h3><span class="item__text">2018-10-31</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/MySql/">MySql</a></li><li class="tag-item"><a class="tag-link" href="/tags/runtime/">runtime</a></li><li class="tag-item"><a class="tag-link" href="/tags/云南自由行/">云南自由行</a></li><li class="tag-item"><a class="tag-link" href="/tags/图片/">图片</a></li><li class="tag-item"><a class="tag-link" href="/tags/定时器/">定时器</a></li><li class="tag-item"><a class="tag-link" href="/tags/组件化/">组件化</a></li><li class="tag-item"><a class="tag-link" href="/tags/自定义转场动画/">自定义转场动画</a></li><li class="tag-item"><a class="tag-link" href="/tags/锁/">锁</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">本站是基于 Hexo 搭建的静态资源博客，主要用于分享日常学习、生活及工作的一些心得总结，欢迎点击右下角订阅 rss。</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>ShenZhen, Guangdong Province, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>anrugood@outlook.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="/img/blogEwm.png" alt="logo" title="Anrue"></div><div class="footer-top__item"><h3 class="item__title">友情链接</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://southpeak.github.io/" title="南峰子" target="_blank">南峰子的技术博客</a></li><li class="list-item"><a href="https://www.kwen.work/" title="Kevin" target="_blank">Kevin‘s Blog</a></li></ul></div></div><div class="footer-top__item"><h3 class="item__title">构建工具</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://hexo.io/" title="Blog Framework" target="_blank">Hexo</a></li><li class="list-item"><a href="https://developer.apple.com/xcode/" title="iOS" target="_blank">Xcode</a></li><li class="list-item"><a href="https://www.python.org/" title="Python 官网" target="_blank">Python</a></li></ul></div></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Anrue" target="_blank">Anrue</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/anru1314" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:anrugood@outlook.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li><li class="social-network__item"><a href="/atom.xml" target="_blank" title="rss"><i class="iconfont icon-rss"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="/js/md5.min.js"></script><script>var tags=["runtime"],gitalk=new Gitalk({clientID:"59f35a92c3aaa2497cde",clientSecret:"602060680fba1dd4c13b187f933b3c715f88001c",repo:"xiaojiejie",owner:"anru1314",admin:["anru1314"],labels:tags,id:new Date(1543649446e3).getTime()>new Date("2018-02-15").getTime()?md5(location.href):location.href});gitalk.render("comment-container")</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>