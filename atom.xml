<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Anrue</title>
  
  <subtitle>Anrue Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/anru1314/"/>
  <updated>2018-11-16T13:36:41.180Z</updated>
  <id>https://github.com/anru1314/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>不可描述的 iOS 锁事</title>
    <link href="https://github.com/anru1314/2018/11/09/iOS/2018-11-09-iOS-%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%94%81/"/>
    <id>https://github.com/anru1314/2018/11/09/iOS/2018-11-09-iOS-中的各种锁/</id>
    <published>2018-11-09T07:51:46.000Z</published>
    <updated>2018-11-16T13:36:41.180Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li>常用锁性能比较：<br><img src="/images/iOS/2018-11-09-iOS-中的各种锁/15414020684047.jpg" alt="图片"></li></ul><blockquote><p><strong>互斥锁(Mutex)</strong>: 是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。它的<strong>原子性</strong>确保了如果一个线程锁定了一个互斥量，将没有其他线程在同一时间可以锁定这个互斥量。它的<strong>唯一性</strong>确保了只有它解锁了这个互斥量，其他线程才可以对其进行锁定。当一个线程锁定一个资源的时候，其他对该资源进行访问的线程将会被挂起，直到该线程解锁了互斥量，其他线程才会被唤醒，进一步才能锁定该资源进行操作。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</p></blockquote><blockquote><p><strong>同步锁</strong>: 是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。也就是说使用信号量可以使多个线程有序访问某个资源。</p></blockquote><blockquote><p><strong>自旋锁</strong>: 自旋锁，和互斥锁类似，都是为了保证线程安全的锁。自旋锁当一个线程获得锁之后，其他线程将会一直循环在那里尝试执行，查看是否该锁被释放。CPU被浪费，执行速度快。所以，此锁比较适用于锁的持有者保存时间较短的情况下。</p></blockquote><blockquote><p><strong>递归锁</strong>: 可以被一个线程多次获得，而不会引起死锁。它记录了成功获得锁的次数，每一次成功的获得锁，必须有一个配套的释放锁和其对应，这样才不会引起死锁。只有当所有的锁被释放之后，其他线程才可以获得锁。</p></blockquote><blockquote><p><strong>显示锁</strong>: 较<code>synchronized</code>内置在代码里面的隐式锁。显示锁需要我们获取锁，释放锁。锁对象越小越好</p></blockquote><h3 id="synchronized-关键字加锁"><a href="#synchronized-关键字加锁" class="headerlink" title="@synchronized 关键字加锁"></a>@synchronized 关键字加锁</h3><p><a href="#">MrPeak杂货铺</a>里面有篇很好的文章：<a href="http://mrpeak.cn/blog/synchronized/" target="_blank" rel="noopener">正确使用多线程同步锁@synchronized()</a></p><p>当我在<a href="https://github.com/anru1314/runtime">源码</a>全局搜索<code>synchronized</code>的时候，很容易就找到了(当然也在Xcode中选择菜单<code>Product-&gt;Perform Action-&gt;Assemble &quot;xxx.m</code>“,看到<code>_objc_sync_enter</code>、<code>_objc_sync_exit</code>这2个函数)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// Begin synchronizing on &apos;obj&apos;. </span><br><span class="line">// Allocates recursive mutex associated with &apos;obj&apos; if needed.</span><br><span class="line">// Returns OBJC_SYNC_SUCCESS once lock is acquired.  </span><br><span class="line">int objc_sync_enter(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    int result = OBJC_SYNC_SUCCESS;</span><br><span class="line"></span><br><span class="line">    if (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, ACQUIRE);</span><br><span class="line">        assert(data);</span><br><span class="line">        data-&gt;mutex.lock();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // @synchronized(nil) does nothing</span><br><span class="line">        if (DebugNilSync) &#123;</span><br><span class="line">            _objc_inform(&quot;NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        objc_sync_nil();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// End synchronizing on &apos;obj&apos;. </span><br><span class="line">// Returns OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR</span><br><span class="line">int objc_sync_exit(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    int result = OBJC_SYNC_SUCCESS;</span><br><span class="line">    </span><br><span class="line">    if (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, RELEASE); </span><br><span class="line">        if (!data) &#123;</span><br><span class="line">            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            bool okay = data-&gt;mutex.tryUnlock();</span><br><span class="line">            if (!okay) &#123;</span><br><span class="line">                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // @synchronized(nil) does nothing</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感兴趣的可以下载源码看看</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p><strong><code>synchronized</code>中传入的<code>object</code>的内存地址，被用作key，通过<code>hash map</code>对应的一个系统维护的递归锁<code>mutex</code>来做同步。</strong><br>所以：</p><ul><li>不管是传入什么类型的object，只要是有内存地址，就能启动同步代码块的效果。</li><li><p><code>synchronized</code>内部采用递归锁<code>mutex</code>（底层应该还是使用的<code>pthread_mutex_t</code>），我们可以嵌套使用，不会造成死锁：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@synchronized (obj) &#123;</span><br><span class="line">    NSLog(@&quot;1st sync&quot;);</span><br><span class="line">    @synchronized (obj) &#123;</span><br><span class="line">        NSLog(@&quot;2nd sync&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我们可以使用<code>pthread_mutex_t</code>递归锁来代替<code>synchronized</code>：<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+(id)fooFerBar:(id)bar &#123;</span><br><span class="line">@synchronized(self) &#123;</span><br><span class="line">   static NSDictionary *foo = nil;</span><br><span class="line">   if (!foo) foo = [NSDictionary dictionaryWithObjects:...];</span><br><span class="line">&#125;</span><br><span class="line">   return [foo objectWithKey:bar];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>上面的例子，<strong>用pthread_mutex_t来代替，虽然很难看，但是性能好很多</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">+(id)fooFerBar:(id)bar &#123;</span><br><span class="line">   static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">   if (pthread_mutex_lock(&amp;mtx)) &#123;</span><br><span class="line">      printf(&quot;lock failed sigh...&quot;);</span><br><span class="line">      exit(-1);</span><br><span class="line">&#125;</span><br><span class="line">   static NSDictionary *foo = nil;</span><br><span class="line">   if (!foo) foo = [NSDictionary dictionaryWithObjects:...];</span><br><span class="line">   if (pthread_mutex_unlock(&amp;mtx) != 0)) &#123;</span><br><span class="line">      printf(&quot;unlock failed sigh...&quot;);</span><br><span class="line">      exit(-1);</span><br><span class="line">&#125;</span><br><span class="line">   return [foo objectWithKey:bar];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>@synchronized(nil)</code>不起任何作用<br>  从源码我们可以看到<code>synchronized</code>传入对象为空时，什么都没有做</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>MrPeak大神也指出了几点注意的地方：</p><ul><li><p>使用<code>@synchronized(self)</code>带来的死锁</p></li><li><p>精准的粒度控制</p></li></ul><p><code>synchronized</code> 是互斥锁，是同类中最方便的隐式锁，性能虽然较差，但是我们也应该把握粒度。</p><p>从源码我们可以知道，@synchronized(obj) 中的 obj 通过 hash 算法存储到了一份手动维护的 cache 中，cache 的 key 使用的是 obj 的内存地址。hash 算法恰能以 O(1)的时间复杂度，以 obj 为 key 取出对应的锁。即内容与位置之间的快速映射关系，也即是一个地址对应一个锁；@synchronized 使用多了之后，快速的通过 obj 取出对应的锁，能够达到优化多线程的性能的作用。</p><p>🔞 <strong>错误做法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@synchronized (sharedToken) &#123;</span><br><span class="line">    [arrA addObject:obj];</span><br><span class="line">&#125;</span><br><span class="line">@synchronized (sharedToken) &#123;</span><br><span class="line">    [arrB addObject:obj];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>❗️❗️❗️ <strong>任何时间都只有一个线程在临界区内执行。</strong></p><p>我们可以这么理解:一栋大楼,里面有很多小房间,每个房间里面装是不同”代码”。现在我们只想一次让一个人进去房间,办法就是在外面”加锁”。”锁”的范围可以加在房间上，也可以加在整栋楼的大门上。而现在这种情况就好比是加在整栋楼的大门上,一旦进去有人进入A房间,即使有人想要进去B房间也会被”锁”在整栋的大门外(<strong>阻塞</strong>)。(整栋楼就是临界区)。所以最好的办法就是进行<strong>粒度控制</strong>,锁加载每个”房间门”的外面。获取锁的对象”范围越大”,临界区”越广”。<br>所以如果是在不同的线程，另一个线程会造成阻塞。</p><p>✅ <strong>正确做法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@synchronized (tokenA) &#123;</span><br><span class="line">    [arrA addObject:obj];</span><br><span class="line">&#125;</span><br><span class="line">@synchronized (tokenB) &#123;</span><br><span class="line">    [arrB addObject:obj];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>注意内部的函数调用<br>{}内部有其他隐蔽的函数调用。比如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@synchronized (tokenA) &#123;</span><br><span class="line">    [arrA addObject:obj];</span><br><span class="line">    [self doSomethingWithA:arrA];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doSomethingWithA内部可能又调用了其他函数，维护doSomethingWithA的工程师可能并没有意识到自己是被锁同步的，由此层层叠叠可能引入更多的函数调用，代码就莫名其妙的越来越慢了，感觉锁的性能差，其实是我们没用好。</p><h3 id="NSLock-h-里面的4中锁"><a href="#NSLock-h-里面的4中锁" class="headerlink" title="NSLock.h 里面的4中锁"></a>NSLock.h 里面的4中锁</h3><p>在【高性能iOS应用开发】书中提到：锁是进入临界区的基础构件。<code>atomic</code>属性和<code>@synchronized</code>块是为了实现边界实用的高级别抽象。</p><p>在<code>NSLock.h</code>里面一共存在4把锁，都遵守<code>NSLocking</code>协议，分别是获取锁，释放锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@protocol NSLocking</span><br><span class="line"></span><br><span class="line">- (void)lock;</span><br><span class="line">- (void)unlock;</span><br></pre></td></tr></table></figure></p><h4 id="NSLock-对象锁"><a href="#NSLock-对象锁" class="headerlink" title="NSLock 对象锁"></a>NSLock 对象锁</h4><p>NSLock 是一种低级别的锁。一旦获取了锁，执行则进入临界区，且不会允许超过一个线程并行执行。释放锁则标记这临界区的结束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// _cpuUsageLock是一个私有字段，也可以是一个属性</span><br><span class="line">- (NSArray *)cpuUsagePerProcessor &#123;</span><br><span class="line">    // 初始化锁</span><br><span class="line">    _cpuUsageLock = [[NSLock alloc] init];</span><br><span class="line">    [_cpuUsageLock lock];</span><br><span class="line">    // TODO: 线程安全代码</span><br><span class="line">    [_cpuUsageLock unlock];//释放锁标记着临界区的结束。其他线程就可以获取锁了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>NSLock 必须在锁定的线程中进行解锁。</strong></p><p><strong>在调用<code>lock</code>之前，<code>NSLock</code>必须先调用<code>unlock</code></strong>。所以如果连续锁定两次，已经获取了锁，再去获取锁，线程会因为等待锁的释放而进入睡眠状态，因此就不可能再释放锁，则会造成死锁问题。如果想要达到递归锁的效果，可以使用<code>NSRecursiveLock</code>。</p><h4 id="NSRecursiveLock-递归锁"><a href="#NSRecursiveLock-递归锁" class="headerlink" title="NSRecursiveLock 递归锁"></a>NSRecursiveLock 递归锁</h4><p><code>NSRecursiveLock</code>允许在被解锁前锁定多次。如果解锁的次数与锁定的次数相匹配，则认为锁释放，其他线程可以获取锁。当类中有多个方法使用同一个锁进行同步，且其中一个方法调用另一个方法时，<code>NSRecursiveLock</code>非常好用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        _lock = [NSRecursiveLock new];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)threadSafeMethod1</span><br><span class="line">&#123;</span><br><span class="line">    [_lock lock];</span><br><span class="line">    //threadSafe code</span><br><span class="line">    [self threadSafeMethod2];</span><br><span class="line">    [_lock unlock];</span><br><span class="line">&#125;</span><br><span class="line">- (void)threadSafeMethod2</span><br><span class="line">&#123;</span><br><span class="line">    [_lock lock];</span><br><span class="line">//    threadSafe code</span><br><span class="line">    [_lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个锁定操作都有一个相应的解锁操作与之匹配。</p><h4 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h4><p><code>NSCondition</code> 可以协调线程之间的执行。一个线程会等待释放锁的变量条件，另一个线程会通知条件变量释放锁，并唤醒等待中的线程。<br><code>NSCondition</code> 可以原子性地释放锁，从而使得其他等待的线程可以获取锁，而初始的线程继续等待。</p><ul><li>举个典型的例子：<br>消费者取得锁，取产品，如果没有，则线程会wait，这时会释放锁，直到有线程唤醒它去消费产品；<br>生产者制造产品，首先也是要取得锁，然后生产，再发signal，这样可唤醒wait的消费者，最后释放锁。</li><li><code>broadcast</code>和 <code>signal</code>的区别：<br>消费者和生产者都有可能会等待，所以<code>broadcast</code>是唤醒所有线程，而signal 只会通知一个等待的线程</li><li>值得注意的是：<code>lock</code>和<code>unlock</code>是成对出现的。</li><li>RAC里面也有一个很好理解的示例： <code>RACCommand</code> 被执行<code>execute</code>的时候底层调用了<code>- (id)first</code>，最终执行代码如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- (id)firstOrDefault:(id)defaultValue success:(BOOL *)success error:(NSError **)error &#123;</span><br><span class="line">NSCondition *condition = [[NSCondition alloc] init];</span><br><span class="line">condition.name = [NSString stringWithFormat:@&quot;[%@] -firstOrDefault: %@ success:error:&quot;, self.name, defaultValue];</span><br><span class="line"></span><br><span class="line">__block id value = defaultValue;</span><br><span class="line">__block BOOL done = NO;</span><br><span class="line"></span><br><span class="line">// Ensures that we don&apos;t pass values across thread boundaries by reference.</span><br><span class="line">__block NSError *localError;</span><br><span class="line">__block BOOL localSuccess;</span><br><span class="line"></span><br><span class="line">[[self take:1] subscribeNext:^(id x) &#123;</span><br><span class="line">[condition lock];</span><br><span class="line"></span><br><span class="line">value = x;</span><br><span class="line">localSuccess = YES;</span><br><span class="line"></span><br><span class="line">done = YES;</span><br><span class="line">[condition broadcast];</span><br><span class="line">[condition unlock];</span><br><span class="line">&#125; error:^(NSError *e) &#123;</span><br><span class="line">[condition lock];</span><br><span class="line"></span><br><span class="line">if (!done) &#123;</span><br><span class="line">localSuccess = NO;</span><br><span class="line">localError = e;</span><br><span class="line">done = YES;</span><br><span class="line">[condition broadcast];</span><br><span class="line">&#125;</span><br><span class="line">[condition unlock];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">[condition lock];</span><br><span class="line">localSuccess = YES;</span><br><span class="line">done = YES;</span><br><span class="line">[condition broadcast];</span><br><span class="line">[condition unlock];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[condition lock];</span><br><span class="line">while (!done) &#123;</span><br><span class="line">[condition wait];</span><br><span class="line">&#125;</span><br><span class="line">if (success != NULL) *success = localSuccess;</span><br><span class="line">if (error != NULL) *error = localError;</span><br><span class="line">[condition unlock];</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="NSConditionLock-条件锁"><a href="#NSConditionLock-条件锁" class="headerlink" title="NSConditionLock 条件锁"></a>NSConditionLock 条件锁</h4><p><code>NSCondition</code> 和 <code>NSConditionLock</code>很像，同样的生产者消费者模型，我们可以使用 NSConditionLock 。当生产者执行执行的时候，消费者可以通过特定的条件获得锁，当生产者完成执行的时候，它将解锁该锁，然后把锁的条件设置成唤醒消费者线程的条件。</p><p>关于<code>NSConditionLock</code>这篇<a href="http://www.cocoachina.com/ios/20161129/18216.html" target="_blank" rel="noopener">文章</a>讲的很好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 用于condition等于特定值的时候获取锁，会阻塞当前线程。</span><br><span class="line">- (void)lockWhenCondition:(NSInteger)condition;</span><br><span class="line"></span><br><span class="line">// 尝试获取锁，获取锁失败时返回NO，try开头的方法会理解解锁。</span><br><span class="line">- (BOOL)tryLock;</span><br><span class="line">- (BOOL)tryLockWhenCondition:(NSInteger)condition;</span><br><span class="line"></span><br><span class="line">// 指定条件时解锁，每次解锁会导致内部的condition值改变为指定的值，同时唤醒其它阻塞的线程检测这里的condition是否满足条件，因此NSConditionLock相对于NSCondition效率更低。</span><br><span class="line">- (void)unlockWithCondition:(NSInteger)condition;</span><br><span class="line"></span><br><span class="line">// 指定条件获取锁，会阻塞当前线程。</span><br><span class="line">- (BOOL)lockBeforeDate:(NSDate *)limit;</span><br><span class="line">- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;</span><br></pre></td></tr></table></figure><h3 id="pthread-mutex-互斥锁（C语言）"><a href="#pthread-mutex-互斥锁（C语言）" class="headerlink" title="pthread_mutex 互斥锁（C语言）"></a>pthread_mutex 互斥锁（C语言）</h3><p><code>pthread</code> 表示 <code>POSIX thread</code>，定义了一组跨平台的线程相关的 API，<code>pthread_mutex</code>表示互斥锁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> Mutex type attributes</span><br><span class="line">*/</span><br><span class="line">// 缺省类型，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后先进先出原则获得锁。</span><br><span class="line">#define PTHREAD_MUTEX_NORMAL        0</span><br><span class="line">// 检错锁，如果同一个线程请求同一个锁，则返回 EDEADLK，否则与普通锁类型动作相同。这样就保证当不允许多次加锁时不会出现嵌套情况下的死锁。</span><br><span class="line">#define PTHREAD_MUTEX_ERRORCHECK    1</span><br><span class="line">// 递归锁，允许同一个线程对同一个锁成功获得多次，并通过多次 unlock 解锁。</span><br><span class="line">#define PTHREAD_MUTEX_RECURSIVE     2</span><br><span class="line">// 适应锁，动作最简单的锁类型，仅等待解锁后重新竞争，没有等待队列。</span><br><span class="line">#define PTHREAD_MUTEX_DEFAULT      PTHREAD_MUTEX_NORMAL</span><br><span class="line"></span><br><span class="line">pthread_mutexattr_t attr;  </span><br><span class="line">pthread_mutexattr_init(&amp;attr);  </span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_NORMAL); </span><br><span class="line"></span><br><span class="line">pthread_mutex_t _lock</span><br><span class="line">// 第二个参数是pthread_mutexattr_t的指针，一般填NULL(即为缺省值)，也可以填&amp;attr</span><br><span class="line">pthread_mutex_init(&amp;_lock, NULL); //创建锁</span><br><span class="line">// 返回0即为成功，失败返回错误码</span><br><span class="line">pthread_mutex_trylock(&amp;_lock) // 尝试获取锁</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;_lock); // 获取锁</span><br><span class="line">// 线程安全代码</span><br><span class="line">pthread_mutex_unlock(&amp;_lock) // 释放锁</span><br><span class="line"></span><br><span class="line">// 一般在delloc方法里面销毁</span><br><span class="line">pthread_mutex_destroy(&amp;_lock); // 销毁锁</span><br><span class="line">pthread_mutexattr_destroy(&amp;attr);</span><br></pre></td></tr></table></figure><p><code>NSLock</code>内部封装了一个 <code>pthread_mutex</code>，属性为 <code>PTHREAD_MUTEX_ERRORCHECK</code>。所以会存在跟<code>NSLock</code>一样的死锁问题。想要在临界区内再获取锁，做好将属性设置为<code>PTHREAD_MUTEX_RECURSIVE</code></p><h3 id="dispatch-semaphore-信号量实现加锁（GCD）"><a href="#dispatch-semaphore-信号量实现加锁（GCD）" class="headerlink" title="dispatch_semaphore 信号量实现加锁（GCD）"></a>dispatch_semaphore 信号量实现加锁（GCD）</h3><p>信号量实现的显示锁</p><p>dispatch_semaphore 是 GCD 用来同步的一种方式，与他相关的共有三个函数，分别是</p><blockquote><ul><li>dispatch_semaphore_create：定义信号量</li><li>dispatch_semaphore_signal：使信号量+1</li><li>dispatch_semaphore_wait：使信号量-1</li></ul></blockquote><blockquote><p>当信号量为 0 时，就会做等待处理，这时其他线程如果访问的话就会让其等待。所以如果信号量在最开始的的时候被设置为1，那么就可以实现“锁”的功能：<br>执行某段代码之前，执行dispatch_semaphore_wait 函数，让信号量减 1 变为 0，执行这段代码。</p></blockquote><blockquote><p>此时如果其他线程过来访问这段代码，就要让其等待。<br>当这段代码在当前线程结束以后，执行 dispatch_semaphore_signal 函数，令信号量再次 加1，那么如果有正在等待的线程就可以访问了。</p></blockquote><p>需要注意的是：如果有多个线程等待，那么后来信号量恢复以后访问的顺序就是线程遇到 dispatch_semaphore_wait 的顺序。</p><p>这也就是信号量和互斥锁的一个区别：互斥量用于线程的互斥，信号线用于线程的同步。</p><p>从首页的图可以看出，自旋锁和信号量加解锁耗时分别排行一二。<a href="http://www.codeceo.com/article/ios-lock.html" target="_blank" rel="noopener">深入理解 iOS 开发中的锁</a>的作者强调指出：<strong>加解锁耗时不能准确反应出锁的效率(比如时间片切换就无法发生)，它只能从一定程度上衡量锁的实现复杂程度。</strong></p><ul><li>SDImageCache 中的例子</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 内存缓存 weakCache  -- NSMapTable</span><br><span class="line">#define LOCK(lock) dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</span><br><span class="line">#define UNLOCK(lock) dispatch_semaphore_signal(lock);</span><br><span class="line"></span><br><span class="line">self.weakCacheLock = dispatch_semaphore_create(1);</span><br><span class="line"></span><br><span class="line">LOCK(self.weakCacheLock);</span><br><span class="line">[self.weakCache setObject:obj forKey:key];</span><br><span class="line">UNLOCK(self.weakCacheLock);</span><br></pre></td></tr></table></figure><h3 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h3><p>关于<code>OSSpinLock</code>自旋锁，可以看大神<a href="https://blog.ibireme.com" target="_blank" rel="noopener">YY</a>的博客<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的OSSpinLock</a></p><p>按照YY大神的描述：<br>操作系统在管理普通线程时，采用的是时间片轮转算法。每个线程会被分配一段时间片(quantum)，通常在 10-100 毫秒左右。当线程用完属于自己的时间片以后，就会被操作系统挂起，放入等待队列中，直到下一次被分配时间片。这样的算法会存在潜在的优先级反转问题。<br>当低优先级的线程获得锁并访问共享资源，这时一个高优先级的线程也尝试获得这个锁，它会处于 spin lock 的忙等状态从而占用大量 CPU（占着cpu，却获取不到锁）。此时低优先级线程无法与高优先级线程争夺 CPU 时间，从而导致任务迟迟完不成、无法释放 lock。<br>除非开发者能保证访问锁的线程全部都处于同一优先级。</p><p>当一个进程正处在某临界区内，任何试图进入其临界区的进程都必须进入代码连续循环，陷入忙等状态。</p><h3 id="os-unfair-lock"><a href="#os-unfair-lock" class="headerlink" title="os_unfair_lock"></a>os_unfair_lock</h3><p>在 iOS 10/macOS 10.12 发布时，苹果提供了新的 <code>os_unfair_lock</code> 作为 <code>OSSpinLock</code> 的替代，并且将 <code>OSSpinLock</code> 标记为了 <code>Deprecated</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">os_unfair_lock_t unfairLock;</span><br><span class="line">unfairLock = &amp;(OS_UNFAIR_LOCK_INIT);</span><br><span class="line">os_unfair_lock_lock(unfairLock);</span><br><span class="line">os_unfair_lock_unlock(unfairLock);</span><br></pre></td></tr></table></figure><h3 id="pthread-rwlock"><a href="#pthread-rwlock" class="headerlink" title="pthread_rwlock"></a>pthread_rwlock</h3><p>从名字就可以看出跟读写相关的锁–读写锁</p><ul><li>当读写锁被一个线程以读模式占用的时候，写操作的其他线程会被阻塞，读操作的其他线程还可以继续进行。</li><li>当读写锁被一个线程以写模式占用的时候，写操作的其他线程会被阻塞，读操作的其他线程也被阻塞。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 初始化锁</span><br><span class="line">pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER</span><br><span class="line"></span><br><span class="line">pthread_rwlock_rdlock(&amp;rwlock);//加读锁</span><br><span class="line">// 临界区</span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);//解锁</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pthread_rwlock_wrlock(&amp;rwlock);//加写锁</span><br><span class="line">// 临界区</span><br><span class="line">pthread_rwlock_unlock(&amp;rwlock);//解锁</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>高性能的时候就用<code>dispatch_semaphore</code>或<code>pthread_mutex</code>。iOS10以上可以用<code>os_unfair_lock</code>。</li><li>想简单方便就用<code>@synchronized</code>。</li></ul><h3 id="优秀博客"><a href="#优秀博客" class="headerlink" title="优秀博客"></a>优秀博客</h3><ul><li><a href="http://www.codeceo.com/article/ios-lock.html" target="_blank" rel="noopener">深入理解 iOS 开发中的锁</a></li><li><a href="http://www.cocoachina.com/ios/20161129/18216.html" target="_blank" rel="noopener">iOS 中的各种锁</a></li><li><a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的OSSpinLock</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;常用锁性能比较：&lt;br&gt;&lt;img src=&quot;/images/iOS/2018-11-09-iOS-中的各种锁/15414020684047.jpg&quot; alt=&quot;图片&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;互斥锁(Mu
      
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/anru1314/categories/iOS/"/>
    
    
      <category term="锁" scheme="https://github.com/anru1314/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>组件化中遇到的问题--篇章一</title>
    <link href="https://github.com/anru1314/2018/10/31/iOS/2018-10-31-%E7%BB%84%E4%BB%B6%E5%8C%96%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98-%E7%AF%87%E7%AB%A0%E4%B8%80/"/>
    <id>https://github.com/anru1314/2018/10/31/iOS/2018-10-31-组件化中遇到的问题-篇章一/</id>
    <published>2018-10-31T08:11:43.000Z</published>
    <updated>2018-11-16T13:48:54.959Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="如何依赖码云，创建私有库"><a href="#如何依赖码云，创建私有库" class="headerlink" title="如何依赖码云，创建私有库"></a>如何依赖码云，创建私有库</h3><p>快点我👉🏻：<a href="https://www.jianshu.com/p/8f7fa64fb7c6" target="_blank" rel="noopener">戳我告诉你怎么创建</a></p><h3 id="基本名词"><a href="#基本名词" class="headerlink" title="基本名词"></a>基本名词</h3><blockquote><p>name：框架名<br>version：当前版本（注意，是当前版本，假如你后续更新了新版本，需要修改此处）<br>summary：简要描述，在pod search ZCPKit的时候会显示该信息。<br>description：详细描述<br>homepage：页面链接<br>license：开源协议<br>author：作者<br>source：源码git地址<br>platform：支持最低ios版本<br>source_files：源文件（可以包含.h和.m）<br>public_header_files：头文件(.h文件)<br>resources：资源文件（配置的文件都会被放到mainBundle中）<br>resource_bundles：资源文件（配置的文件会放到你自己指定的bundle中）<br>frameworks：依赖的.framework系统框架<br>libraries：依赖的.a系统库<br>vendored_frameworks：依赖的.framework非系统框架<br>vendored_libraries：依赖的.a非系统的静态库<br>dependency：依赖的三方库</p></blockquote><h3 id="spec-文件的基本认识"><a href="#spec-文件的基本认识" class="headerlink" title="spec 文件的基本认识"></a>spec 文件的基本认识</h3><ul><li>私有库：指的是我们真正放置组件代码的地方。</li><li>索引库：存放<code>spec</code>文件的地方，用于索引到代码的位置。<br>  打个比方，索引库就好比指针，私有库就好比对象，指针中存放了对象的地址，通过地址可以找到对象！</li><li><code>Podfile</code> ：项目依赖哪个 <code>pod</code>，以何种方式依赖，它的 <code>podspec</code> 放在哪里  </li></ul><h3 id="spec-库引用问题"><a href="#spec-库引用问题" class="headerlink" title="spec 库引用问题"></a>spec 库引用问题</h3><ul><li>模块怎么依赖其他<code>pod</code>库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  // 这样就可以依赖了 </span><br><span class="line">s.dependency &apos;ReactiveObjC&apos;</span><br><span class="line">s.dependency &apos;SDWebImage&apos;, &apos;~&gt; 3.7.2&apos;</span><br><span class="line">s.dependency &apos;MBProgressHUD&apos;, &apos;~&gt; 1.1.0&apos;</span><br><span class="line"></span><br><span class="line">// 不能这样写,这样写无效</span><br><span class="line">s.dependency &apos;SDWebImage&apos;, &apos;MBProgressHUD&apos;</span><br></pre></td></tr></table></figure><ul><li>基础模块引用了自己打包的<code>framework</code>，开发测试时可以找到头文件，主工程引入却又找不到？</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 第一步：检测source_files， 如果是只包含 Classes文件下的.h,.m文件</span><br><span class="line">s.source_files = &apos;ANEGBase/Classes/*.&#123;h,m&#125;&apos;</span><br><span class="line">// 改成下面：</span><br><span class="line">s.source_files = &apos;ANEGBase/Classes/**/*&apos;</span><br><span class="line"></span><br><span class="line">// 第二步：引用自己或者第三方库，需要指定库的具体路径</span><br><span class="line">s.vendored_frameworks = &quot;ANEGBase/Classes/ANAppUtils.framework&quot;</span><br></pre></td></tr></table></figure><ul><li>本地私有库开发时，显示出良好的文件层划分，远程导入时，全部在一个文件夹里，而且很乱</li></ul><p>使用<code>subspec</code>，在里面添加相应的<code>ss.source_files、dependency</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">s.subspec &apos;ANCustomView&apos; do |ss|</span><br><span class="line">      ss.source_files = &apos;ANEGBase/Classes/ANCustomView/*.h&apos;</span><br><span class="line">      # 多层嵌套</span><br><span class="line">      ss.subspec &apos;ANLoadButton&apos; do |sss|</span><br><span class="line">          sss.source_files = &apos;ANEGBase/Classes/ANCustomView/    ANLoadButton/*&apos;</span><br><span class="line">    </span><br><span class="line">      end</span><br><span class="line">      ss.subspec &apos;JKCountDownButton&apos; do |sss|</span><br><span class="line">          sss.source_files = &apos;ANEGBase/Classes/ANCustomView/JKCountDownButton/*&apos;</span><br><span class="line">      end</span><br><span class="line">      ss.subspec &apos;ANAppControls&apos; do |sss|</span><br><span class="line">          sss.source_files = &apos;ANEGBase/Classes/ANCustomView/ANAppControls/*&apos;</span><br><span class="line">      end</span><br><span class="line">  end</span><br></pre></td></tr></table></figure><ul><li>当文件分层时，一个文件依赖另外一个文件的内容时</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.subspec &apos;ANTransition&apos; do |ss|</span><br><span class="line">    ss.dependency &apos;ANEGBase/ANBase&apos;</span><br><span class="line">    ss.source_files = &apos;ANEGBase/Classes/ANTransition/**&apos;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><img src="/images/iOS/2018-10-31-组件化中遇到的问题-篇章一/15373406145758.jpg" alt="图片"></p><p><strong>注意</strong>：依赖的时候写的路径并不是真是的物理路径，而是层及路径<br><strong>例如</strong>：<code>ANBase</code> 的真实物理路径： <code>&#39;ANEGBase/Classes/ANBase/**.*&#39;</code>，但是也要写成  <code>ss.dependency &#39;ANEGBase/ANBase&#39;</code></p><ul><li>【报错】 <code>ERROR | [iOS] [ANEGBase/ANCustomView] file patterns: The source_files pattern did not match any file.</code></li></ul><p>这个错误使用指令<code>pod lib lint ANEGBase.podspec</code> 检查文件是否合法时发生的。<br>是设置<code>s.source_files</code>时，路径不正确。这里的路径是相对于<code>ANEGBase.podspec</code>文件的，如果是与<code>ANEGBase.podspec</code>同级的文件夹, 直接写文件夹名称即可, 如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source_files = ANTransition</span><br></pre></td></tr></table></figure></p><p>如果是多级目录，必须要添加文件层级结构，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss.source_files = &apos;ANEGBase/Classes/ANTransition/**&apos;</span><br></pre></td></tr></table></figure><ul><li><code>spec</code> 本地验证报错<code>“non_modular_includes_in_framework_modules”</code></li></ul><p>因为打包的<code>framework</code>使用了<code>pod</code> 引入了第三方，而将这个<code>framework</code>直接拖到项目中就会报这个错误，但是在<code>xcode built-setting</code>中可以关掉这个检测机制</p><p>而用<code>cocoapods</code> 就只能使用下面的方式了(在stackoverflow翻了好久)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.user_target_xcconfig = &#123; &apos;CLANG_ALLOW_NON_MODULAR_INCLUDES_IN_FRAMEWORK_MODULES&apos; =&gt; &apos;YES&apos; &#125;</span><br></pre></td></tr></table></figure><h3 id="怎么引用图片"><a href="#怎么引用图片" class="headerlink" title="怎么引用图片"></a>怎么引用图片</h3><p>引用图片是用bundle好，还是assest好？</p><ol><li>使用<code>s.resources</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.resources = [&quot;Images/*.png&quot;, &quot;Sounds/*&quot;]</span><br></pre></td></tr></table></figure></li></ol><p>但是这些资源会在打包的时候直接拷贝的app的<code>Bundle</code>中，这样说不定会和其它资源产生命名冲突</p><ol start="2"><li>将资源都放在<code>bundle</code>里，再使用<code>s.resources</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.resource = &quot;ANEGBase/Assets/ANAppUtils.bundle&quot;</span><br></pre></td></tr></table></figure></li></ol><p>打包时候这个<code>bundle</code>会直接拷贝进<code>app</code>的<code>mainBundle</code>中，所以使用的时候需要在<code>mainBundle</code>里面找这个<code>bundle</code>，然后再找资源。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSURL *bundleURL = [[NSBundle mainBundle] URLForResource:@&quot;xxx&quot; withExtension:@&quot;bundle&quot;];</span><br><span class="line">NSBundle *bundle = [NSBundle bundleWithURL:bundleURL];</span><br><span class="line">UIImage *img = [UIImage imageNamed:icon inBundle:bundle compatibleWithTraitCollection:nil];</span><br></pre></td></tr></table></figure></p><ol start="3"><li>使用<code>s.resource_bundles</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.resource_bundles = &#123;</span><br><span class="line">&apos;ANAppUtils&apos; =&gt; [&apos;Resources/*.png&apos;],</span><br><span class="line">&apos;xxx&apos; =&gt; [&apos;xxx/*.png&apos;]</span><br></pre></td></tr></table></figure></li></ol><p>这种方法利用 <code>framework</code> 的命名空间，有效防止了资源冲突。<br>使用方法是先拿到最外面的 <code>bundle</code>，然后再去找下面指定名字 的 <code>bundle</code> 对象，再搜索具体资源。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 查找当前文件所在的bundle包可以使用NSBundle类的+ (NSBundle *)bundleForClass:(Class)aClass;方法 </span><br><span class="line"></span><br><span class="line">NSBundle *bundle = [NSBundle bundleForClass:[ANXXXClass class]];</span><br><span class="line">NSURL *bundleURL = [bundle URLForResource:@&quot;ANXXX&quot; withExtension:@&quot;bundle&quot;];</span><br><span class="line">NSBundle *resourceBundle = [NSBundle bundleWithURL: bundleURL];</span><br><span class="line">UIImage *img = [UIImage imageNamed:icon inBundle:bundle compatibleWithTraitCollection:nil];</span><br></pre></td></tr></table></figure><ol start="4"><li>将资源都放在<code>assest</code>里，使用<code>s.resource_bundles</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  s.resource_bundles = &#123;</span><br><span class="line">  &apos;ANEGBundleMudles&apos; =&gt; [&apos;ANEGBundleMudles/Assets/*&apos;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>s.resource_bundles</code> 是用来存放资源文件的，<code>cocoapods</code> 也支持了 <code>Assets</code> ，我们可以<code>Assets</code>管理图片<br>这种方法,在项目工程编译后，会出现在包的的 <a href="#">Frameworks/ANEGBundleMudles.framework/ANEGBundleMudles.bundle</a> , 找到包右键<code>show in finder</code>：</p><p><img src="/images/iOS/2018-10-31-组件化中遇到的问题-篇章一/15409724575976.jpg" alt="图片"><br>因为是<code>Assets</code>管理，使用方式同第三步</p><hr><h3 id="xib资源怎么加载"><a href="#xib资源怎么加载" class="headerlink" title="xib资源怎么加载"></a>xib资源怎么加载</h3><p>待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;如何依赖码云，创建私有库&quot;&gt;&lt;a href=&quot;#如何依赖码云，创建私有库&quot; class=&quot;headerlink&quot; title=&quot;如何依赖码云，创建私有库&quot;&gt;&lt;/a&gt;如何依赖码云，创建私有库&lt;/h3&gt;&lt;p&gt;快点我👉🏻：&lt;a h
      
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/anru1314/categories/iOS/"/>
    
    
      <category term="组件化" scheme="https://github.com/anru1314/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>常见图片格式</title>
    <link href="https://github.com/anru1314/2018/10/10/python/2018-10-10-%E5%B8%B8%E8%A7%81%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F/"/>
    <id>https://github.com/anru1314/2018/10/10/python/2018-10-10-常见图片格式/</id>
    <published>2018-10-10T08:33:26.000Z</published>
    <updated>2018-11-16T13:49:16.015Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>图片有不同的格式，每种格式都有自己的特性，了解这些特效，可以方便我们在制作网页时选取适合的图片格式，图片格式及特性如下：</p><h4 id="psd"><a href="#psd" class="headerlink" title="psd"></a>psd</h4><p>psd是photoshop的专用格式，UI设计师使用photoshop设计效果图，最后会将psd格式的效果图交付给前端工程师，这种格式是不压缩的，而且保留了图层、透明和半透明等图片信息，所以这种图片格式的容量相对来说是很大的，前端工程师使用这种格式的效果图来切图制作网页，但是网页中不会使用这个格式的图片，它的作用一是保存图片的原始数据，二是方便图片的修改。</p><h4 id="jpg"><a href="#jpg" class="headerlink" title="jpg"></a>jpg</h4><p>jpg是一种有损压缩格式，压缩效率高，容量相对来说最小，网络传输速度快，它不能存为透明背景，在网页中应用最广，一般在不需要透明背景的时候就使用这种图片。</p><h4 id="gif"><a href="#gif" class="headerlink" title="gif"></a>gif</h4><p>gif是一种无损压缩格式的图片，最多只有256种颜色，颜色丰富的图片转化为这种格式会颜色失真。它的背景可以是透明的，但不能是半透明的，透明背景中的图像，如果边缘轮廓是曲线的，会产生锯齿，它还可以保存为动画格式。</p><h4 id="png"><a href="#png" class="headerlink" title="png"></a>png</h4><p>png的目的是为了代替gif图片，无损压缩，背景可以是透明或者半透明的，透明图像边缘光滑，没有锯齿，网页中需要透明或者半透明背景的图片，首选是png图片。png也是firework的专用格式，也可以包含图层信息。firework是另外一款可以和photoshop相比的图像处理软件。也有少量的UI设计师使用这种软件来设计网页效果图，他们设计的效果图就是带图层的png格式的，碰到这种设计师，如果我们习惯了photoshop切图，可以将带图层的png效果图转化成psd图片再处理。</p><h4 id="webp"><a href="#webp" class="headerlink" title="webp"></a>webp</h4><p>它是由谷歌于2010年推出的新一代图片格式，在压缩方面比当前jpg格式更优越，在质量相同的情况下，WebP格式图像的体积要比jpg格式图像小40%，不过这种图片还没有得到广泛的浏览器支持，仅在Chrome和Opera上支持，在其他浏览器上需要安装插件才可以显示，目前还没有大规模使用。</p><h4 id="位图和矢量图"><a href="#位图和矢量图" class="headerlink" title="位图和矢量图"></a>位图和矢量图</h4><p>位图也叫点阵图，是由一个个的方形的像素点排列在一起拼接而成的，位图在放大时，图像会失真。上面讲的5种图像都属于位图。<br>矢量图和位图组成图像的原理不同，它的图像轮廓是由函数曲线生成的，当放大图像时，实际的原理就是将曲线乘以一个倍数，图像可以轻易地放大，而且不会出现像素块，图像边缘也不会出现锯齿。</p><h4 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h4><p>svg是一种矢量二维图形格式，它是基于xml标记语言描述的，可以通过任何文本编辑器创建。它的优点是文件容量小，放大不失真，而且背景也可以是透明的。目前大量使用这种格式来制作网页图标或者网页地图，由于它是矢量的，所以在不同终端屏幕上(pc、手机)都有很好的显示效果。</p><h4 id="flash"><a href="#flash" class="headerlink" title="flash"></a>flash</h4><p>flash是一种矢量动画文件格式，曾经在网络上风靡一时，如今已逐渐退出历史舞台，原因是它的技术更新跟不上发展，这种格式既可以是静态的图形，还可以是多媒体动画，还可以加入用户交互和数据，这是它曾经很流行的原因，这种格式名为swf，flash是对它的统称。这种格式在网页中已经很少使用了，它的很多优秀特性，可以用HTML5取代。swf文件中衍生出一种视频格式flv，它是一种流媒体视频格式，由于它有文件容量小，可以边下载，边观看等优点，目前广泛应用在视频网站中。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在网页制作中，如何选择合适的图片格式呢？<br>1、网页制作中，如果要使用不透明背景的图片，就使用jpg图片；如果要使用透明或者半透明背景的图片，就使用png图片；<br>2、制作网页图标时候，如果图标含多种颜色，可以使用gif或png图片；如果图标是单色，而且要求有很好的显示效果，可以使用svg；如果是动画图标，可以使用gif。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;图片有不同的格式，每种格式都有自己的特性，了解这些特效，可以方便我们在制作网页时选取适合的图片格式，图片格式及特性如下：&lt;/p&gt;
&lt;h4 i
      
    
    </summary>
    
      <category term="Python" scheme="https://github.com/anru1314/categories/Python/"/>
    
    
      <category term="图片" scheme="https://github.com/anru1314/tags/%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>MySql笔记</title>
    <link href="https://github.com/anru1314/2018/10/09/python/2018-10-09-MySql%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/anru1314/2018/10/09/python/2018-10-09-MySql笔记/</id>
    <published>2018-10-09T08:33:51.000Z</published>
    <updated>2018-11-16T14:03:05.905Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="使用命令开启、连接"><a href="#使用命令开启、连接" class="headerlink" title="使用命令开启、连接"></a>使用命令开启、连接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql.server start/stop</span><br><span class="line">开启服务</span><br><span class="line"></span><br><span class="line">mysql -u root -p</span><br><span class="line">回车后输入密码，当前设置的密码为mysql</span><br><span class="line"></span><br><span class="line">\q 退出 \c 清空 （语句后面加分号;）</span><br></pre></td></tr></table></figure><h3 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h3><ul><li>一般在公司开发中，可能会将数据库统一搭建在一台服务器上，所有开发人员共用一个数据库，而不是在自己的电脑中配置一个数据库</li><li>运行命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -hip地址 -uroot -p</span><br></pre></td></tr></table></figure><ul><li>-h后面写要连接的主机ip地址</li><li>-u后面写连接的用户名</li><li>-p回车后写密码</li></ul><h2 id="数据库、表、数据操作"><a href="#数据库、表、数据操作" class="headerlink" title="数据库、表、数据操作"></a>数据库、表、数据操作</h2><hr><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><ul><li>查看所有数据库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure><ul><li>创建数据库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database 数据库名 charset=utf8;</span><br></pre></td></tr></table></figure><ul><li>删除数据库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database 数据库名;</span><br></pre></td></tr></table></figure><ul><li>切换数据库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名;</span><br></pre></td></tr></table></figure><ul><li>查看当前选择的数据库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select database();</span><br></pre></td></tr></table></figure><hr><h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><ul><li>查看当前数据库中所有表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure><ul><li>创建表</li><li>auto_increment表示自动增长</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table 表名(列及类型);</span><br><span class="line">如：</span><br><span class="line">create table students(</span><br><span class="line">id int auto_increment primary key,</span><br><span class="line">sname varchar(10) not null</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>修改表</li></ul><p>alter 是修改表结构，如对字段增加、删除、修改类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add|change|drop 列名 类型;</span><br><span class="line">如：</span><br><span class="line">alter table students add birthday datetime;</span><br></pre></td></tr></table></figure><ul><li>删除表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table 表名;</span><br></pre></td></tr></table></figure><ul><li>查看表结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc 表名;</span><br></pre></td></tr></table></figure><ul><li>更改表名称</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename table 原表名 to 新表名;</span><br></pre></td></tr></table></figure><ul><li>查看表的创建语句</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create table &apos;表名&apos;;</span><br></pre></td></tr></table></figure><hr><h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><ul><li>查询</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 表名</span><br></pre></td></tr></table></figure><ul><li>增加</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">全列插入：insert into 表名 values(...);</span><br><span class="line">缺省插入：insert into 表名(列1,...) values(值1,...);</span><br><span class="line">同时插入多条数据：insert into 表名 values(...),(...)...;</span><br><span class="line">或insert into 表名(列1,...) values(值1,...),(值1,...)...;</span><br><span class="line">主键列是自动增长，但是在全列插入时需要占位，通常使用0，插入成功后以实际数据为准</span><br></pre></td></tr></table></figure><ul><li>修改</li></ul><p>update用来修改表中的数据，修改某一行某一列的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update 表名 set 列1=值1,... where 条件</span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from 表名 where 条件</span><br></pre></td></tr></table></figure><ul><li>逻辑删除，本质就是修改操作update</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table students add isdelete bit default 0;</span><br><span class="line">如果需要删除则</span><br><span class="line">update students isdelete=1 where ...;</span><br></pre></td></tr></table></figure><hr><h3 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h3><h4 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h4><ul><li>运行mysqldump命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqldump –uroot –p 数据库名 &gt; ~/Desktop/备份文件.sql;</span><br><span class="line">按提示输入mysql的密码</span><br></pre></td></tr></table></figure><h4 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h4><p>其实就是创建表，插入表的一个过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">连接mysql，创建数据库</span><br><span class="line"></span><br><span class="line">退出连接，执行如下命令</span><br><span class="line"></span><br><span class="line">mysql -u root –p 数据库名 &lt; ~/Desktop/备份文件.sql</span><br><span class="line">根据提示输入mysql密码</span><br></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>查询的基本语法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 表名;</span><br></pre></td></tr></table></figure><ul><li>from关键字后面写表名，表示数据来源于是这张表</li><li>select后面写表中的列名，如果是*表示在结果中显示表中所有列</li><li>在select后面的列名部分，可以使用as为列起别名，这个别名出现在结果集中</li><li><p>如果要查询多个列，之间使用逗号分隔</p></li><li><p>消除重复行<br>在select后面列前使用distinct可以消除重复的行</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct gender from students;</span><br></pre></td></tr></table></figure><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>使用where子句对表中的数据筛选，结果为true的行会出现在结果集中<br>语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from 表名 where 条件;</span><br></pre></td></tr></table></figure><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">等于=</span><br><span class="line">大于&gt;</span><br><span class="line">大于等于&gt;=</span><br><span class="line">小于&lt;</span><br><span class="line">小于等于&lt;=</span><br><span class="line">不等于!=或&lt;&gt;</span><br></pre></td></tr></table></figure><ul><li>查询编号大于3的学生</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from students where id&gt;3;</span><br></pre></td></tr></table></figure><ul><li>查询编号不大于4的科目</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from subjects where id&lt;=4;</span><br></pre></td></tr></table></figure><ul><li>查询姓名不是“黄蓉”的学生</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from students where sname!=&apos;黄蓉&apos;;</span><br></pre></td></tr></table></figure><ul><li>查询没被删除的学生</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from students where isdelete=0;</span><br></pre></td></tr></table></figure><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">and</span><br><span class="line">or</span><br><span class="line">not</span><br></pre></td></tr></table></figure><ul><li>查询编号大于3的女同学</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from students where id&gt;3 and gender=0;</span><br></pre></td></tr></table></figure><ul><li>查询编号小于4或没被删除的学生</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from students where id&lt;4 or isdelete=0;</span><br></pre></td></tr></table></figure><ul><li>模糊查询<br><strong>like</strong></li><li>%表示任意多个任意字符</li><li>_表示一个任意字符</li><li>查询姓黄的学生</li></ul><figure class="highlight plain"><figcaption><span>* from students where sname like '黄%';</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">* 查询姓黄并且名字是一个字的学生</span><br></pre></td></tr></table></figure><p>select * from students where sname like ‘黄_’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 查询姓黄或叫靖的学生</span><br><span class="line"></span><br><span class="line">```select * from students where sname like &apos;黄%&apos; or sname like &apos;%靖%&apos;;</span><br></pre></td></tr></table></figure></p><h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><ul><li>in表示在一个非连续的范围内</li><li>查询编号是1或3或8的学生</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from students where id in(1,3,8);</span><br></pre></td></tr></table></figure><ul><li><p><strong>between … and …表示在一个连续的范围内</strong></p></li><li><p>查询学生是3至8的学生</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from students where id between 3 and 8;</span><br></pre></td></tr></table></figure><ul><li>查询学生是3至8的男生</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from students where id between 3 and 8 and gender=1;</span><br></pre></td></tr></table></figure><h4 id="空判断"><a href="#空判断" class="headerlink" title="空判断"></a>空判断</h4><p><strong>注意：null与’’是不同的</strong><br><strong>判空is null</strong></p><ul><li>查询没有填写地址的学生</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from students where hometown is null;</span><br></pre></td></tr></table></figure><p><strong>判非空is not null</strong></p><ul><li>查询填写了地址的学生</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from students where hometown is not null;</span><br></pre></td></tr></table></figure><ul><li>查询填写了地址的女生</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from students where hometown is not null and gender=0;</span><br></pre></td></tr></table></figure><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>小括号，not，比较运算符，逻辑运算符<br>and比or先运算，如果同时出现并希望先算or，需要结合()使用</p><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p><strong>为了快速得到统计数据，提供了5个聚合函数</strong></p><ul><li>count(*)表示计算总行数，括号中写星与列名，结果是相同的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查询学生总数</span><br><span class="line">select count(*) from students;</span><br></pre></td></tr></table></figure><ul><li>max(列)表示求此列的最大值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查询女生的编号最大值</span><br><span class="line">select max(id) from students where gender=0;</span><br></pre></td></tr></table></figure><ul><li>min(列)表示求此列的最小值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查询未删除的学生最小编号</span><br><span class="line">select min(id) from students where isdelete=0;</span><br></pre></td></tr></table></figure><ul><li>sum(列)表示求此列的和</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查询男生的编号之后</span><br><span class="line">select sum(id) from students where gender=1;</span><br></pre></td></tr></table></figure><ul><li>avg(列)表示求此列的平均值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查询未删除女生的编号平均值</span><br><span class="line">select avg(id) from students where isdelete=0 and gender=0;</span><br></pre></td></tr></table></figure><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><blockquote><p>按照字段分组，表示此字段相同的数据会被放到一个组中<br>分组后，只能查询出相同的数据列，对于有差异的数据列无法出现在结果集中<br>可以对分组后的数据进行统计，做聚合运算</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">select 列1,列2,聚合... from 表名 group by 列1,列2,列3...</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查询男女生总数</span><br><span class="line">select gender as 性别,count(*)</span><br><span class="line">from students</span><br><span class="line">group by gender;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查询各城市人数</span><br><span class="line">select hometown as 家乡,count(*)</span><br><span class="line">from students</span><br><span class="line">group by hometown;</span><br></pre></td></tr></table></figure><blockquote><p>分组后的数据筛选</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">select 列1,列2,聚合... from 表名</span><br><span class="line">group by 列1,列2,列3...</span><br><span class="line">having 列1,...聚合...</span><br><span class="line">having后面的条件运算符与where的相同</span><br></pre></td></tr></table></figure><ul><li>查询男生总人数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">方案一</span><br><span class="line">select count(*)</span><br><span class="line">from students</span><br><span class="line">where gender=1;</span><br><span class="line"></span><br><span class="line">方案二：</span><br><span class="line">select gender as 性别,count(*)</span><br><span class="line">from students</span><br><span class="line">group by gender</span><br><span class="line">having gender=1;</span><br><span class="line">对比where与having</span><br></pre></td></tr></table></figure><p><strong>where是对from后面指定的表进行数据筛选，属于对原始数据的筛选<br>having是对group by的结果进行筛选</strong></p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul><li>为了方便查看数据，可以对数据进行排序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">select * from 表名</span><br><span class="line">order by 列1 asc|desc,列2 asc|desc,...</span><br></pre></td></tr></table></figure><blockquote><p>将行数据按照列1进行排序，如果某些行列1的值相同时，则按照列2排序，以此类推<br>默认按照列值从小到大排列<br><strong>asc从小到大排列，即升序</strong><br><strong>desc从大到小排序，即降序</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查询未删除男生学生信息，按学号降序</span><br><span class="line">select * from students</span><br><span class="line">where gender=1 and isdelete=0</span><br><span class="line">order by id desc;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查询未删除科目信息，按名称升序</span><br><span class="line">select * from subject</span><br><span class="line">where isdelete=0</span><br><span class="line">order by stitle;</span><br></pre></td></tr></table></figure><hr><h3 id="获取部分行-分页"><a href="#获取部分行-分页" class="headerlink" title="获取部分行(分页)"></a>获取部分行(分页)</h3><ul><li>当数据量过大时，在一页中查看数据是一件非常麻烦的事情</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法</span><br><span class="line">select * from 表名</span><br><span class="line">limit start,count</span><br><span class="line">从start开始，获取count条数据</span><br><span class="line">start索引从0开始</span><br></pre></td></tr></table></figure><p>示例：分页</p><ul><li>已知：每页显示m条数据，当前显示第n页</li><li>求总页数：此段逻辑后面会在python中实现<ul><li>查询总条数p1</li><li>使用p1除以m得到p2</li><li>如果整除则p2为总数页</li><li>如果不整除则p2+1为总页数</li></ul></li><li>求第n页的数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from students</span><br><span class="line">where isdelete=0</span><br><span class="line">limit (n-1)*m,m</span><br></pre></td></tr></table></figure><ul><li>完整的select语句</li></ul><figure class="highlight plain"><figcaption><span>distinct *</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from 表名</span><br><span class="line">where ....</span><br><span class="line">group by ... having ...</span><br><span class="line">order by ...</span><br><span class="line">limit star,count</span><br></pre></td></tr></table></figure><ul><li>执行顺序为：</li></ul><figure class="highlight plain"><figcaption><span>表名</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">where ....</span><br><span class="line">group by ...</span><br><span class="line">select distinct *</span><br><span class="line">having ...</span><br><span class="line">order by ...</span><br><span class="line">limit star,count</span><br></pre></td></tr></table></figure><p>ps ：实际使用中，只是语句中某些部分的组合，而不是全部</p><hr><h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><ul><li>实体与实体之间有3种对应关系，这些关系也需要存储下来</li><li>在开发中需要对存储的数据进行一些处理，用到内置的一些函数</li><li>视图用于完成查询语句的封装</li><li>事务可以保证复杂的增删改操作有效</li></ul><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><ul><li>创建成绩表scores，结构如下<ul><li>id</li><li>学生</li><li>科目</li><li>成绩</li></ul></li><li>思考：学生列应该存什么信息呢？</li><li><p>答：学生列的数据不是在这里新建的，而应该从学生表引用过来，关系也是一条数据；根据范式要求应该存储学生的编号，而不是学生的姓名等其它信息<br>同理，科目表也是关系列，引用科目表中的数据<br>关系</p></li><li><p>创建表的语句如下</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table scores(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">stuid int,</span><br><span class="line">subid int,</span><br><span class="line">score decimal(5,2)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h5><ul><li>思考：怎么保证关系列数据的有效性呢？任何整数都可以吗？</li><li>答：必须是学生表中id列存在的数据，可以通过外键约束进行数据的有效性验证</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为stuid添加外键约束</span><br><span class="line">alter table scores add constraint stu_sco foreign key(stuid) references students(id);</span><br></pre></td></tr></table></figure><ul><li>此时插入或者修改数据时，如果stuid的值在students表中不存在则会报错</li><li>在创建表时可以直接创建约束</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table scores(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">stuid int,</span><br><span class="line">subid int,</span><br><span class="line">score decimal(5,2),</span><br><span class="line">foreign key(stuid) references students(id),</span><br><span class="line">foreign key(subid) references subjects(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h6 id="外键的级联操作"><a href="#外键的级联操作" class="headerlink" title="外键的级联操作"></a>外键的级联操作</h6><ul><li>在删除students表的数据时，如果这个id值在scores中已经存在，则会抛异常</li><li>推荐使用逻辑删除，还可以解决这个问题</li><li>可以创建表时指定级联操作，也可以在创建表后再修改外键的级联操作</li></ul><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table scores add constraint stu_sco foreign key(stuid) references students(id) on delete cascade;</span><br></pre></td></tr></table></figure><ul><li>级联操作的类型包括：<ul><li>restrict（限制）：默认值，抛异常</li><li>cascade（级联）：如果主表的记录删掉，则从表中相关联的记录都将被删除</li><li>set null：将外键设置为空</li><li>no action：什么都不做</li></ul></li></ul><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="先看个问题"><a href="#先看个问题" class="headerlink" title="先看个问题"></a>先看个问题</h4><ul><li>问：查询每个学生每个科目的分数<blockquote><p>分析：学生姓名来源于students表，科目名称来源于subjects，分数来源于scores表，怎么将3个表放到一起查询，并将结果显示在同一个结果集中呢？<br>答：当查询结果来源于多张表时，需要使用连接查询</p></blockquote></li><li>关键：找到表间的关系，当前的关系是<ul><li>students表的id—scores表的stuid</li><li>subjects表的id—scores表的subid</li></ul></li><li>则上面问题的答案是：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select students.sname,subjects.stitle,scores.score</span><br><span class="line">from scores</span><br><span class="line">inner join students on scores.stuid=students.id</span><br><span class="line">inner join subjects on scores.subid=subjects.id;</span><br></pre></td></tr></table></figure><ul><li>结论：当需要对有关系的多张表进行查询时，需要使用连接join</li></ul><h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><ul><li>连接查询分类如下：<ul><li>表A inner join 表B：表A与表B匹配的行会出现在结果中</li><li>表A left join 表B：表A与表B匹配的行会出现在结果中，外加表A中独有的数据，未对应的数据使用null填充</li><li>表A right join 表B：表A与表B匹配的行会出现在结果中，外加表B中独有的数据，未对应的数据使用null填充</li></ul></li><li>在查询或条件中推荐使用“表名.列名”的语法</li><li>如果多个表中列名不重复可以省略“表名.”部分</li><li>如果表的名称太长，可以在表名后面使用’ as 简写名’或’ 简写名’，为表起个临时的简写名称</li></ul><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>查询学生的姓名、平均分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select students.sname,avg(scores.score)</span><br><span class="line">from scores</span><br><span class="line">inner join students on scores.stuid=students.id</span><br><span class="line">group by students.sname;</span><br></pre></td></tr></table></figure><p>查询男生的姓名、总分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select students.sname,avg(scores.score)</span><br><span class="line">from scores</span><br><span class="line">inner join students on scores.stuid=students.id</span><br><span class="line">where students.gender=1</span><br><span class="line">group by students.sname;</span><br></pre></td></tr></table></figure><p>查询科目的名称、平均分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select subjects.stitle,avg(scores.score)</span><br><span class="line">from scores</span><br><span class="line">inner join subjects on scores.subid=subjects.id</span><br><span class="line">group by subjects.stitle;</span><br></pre></td></tr></table></figure><p>查询未删除科目的名称、最高分、平均分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select subjects.stitle,avg(scores.score),max(scores.score)</span><br><span class="line">from scores</span><br><span class="line">inner join subjects on scores.subid=subjects.id</span><br><span class="line">where subjects.isdelete=0</span><br><span class="line">group by subjects.stitle;</span><br></pre></td></tr></table></figure><h3 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h3><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><ul><li>查询支持嵌套使用</li><li>查询各学生的语文、数学、英语的成绩</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select sname,</span><br><span class="line">(select sco.score from scores sco inner join subjects sub on sco.subid=sub.id where sub.stitle=&apos;语文&apos; and stuid=stu.id) as 语文,</span><br><span class="line">(select sco.score from  scores sco inner join subjects sub on sco.subid=sub.id where sub.stitle=&apos;数学&apos; and stuid=stu.id) as 数学,</span><br><span class="line">(select sco.score from  scores sco inner join subjects sub on sco.subid=sub.id where sub.stitle=&apos;英语&apos; and stuid=stu.id) as 英语</span><br><span class="line">from students stu;</span><br></pre></td></tr></table></figure><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><ul><li>对于复杂的查询，在多次使用后，维护是一件非常麻烦的事情</li><li><p>解决：定义视图<br>视图本质就是对查询的一个封装</p></li><li><p>定义视图</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create view stuscore as </span><br><span class="line">select students.*,scores.score from scores</span><br><span class="line">inner join students on scores.stuid=students.id;</span><br></pre></td></tr></table></figure><ul><li>视图的用途就是查询</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stuscore;</span><br></pre></td></tr></table></figure><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><ul><li>当一个业务逻辑需要多个sql完成时，如果其中某条sql语句出错，则希望整个操作都退回</li><li>使用事务可以完成退回的功能，保证业务逻辑的正确性</li><li>事务四大特性(简称ACID)<ul><li>原子性(Atomicity)：事务中的全部操作在数据库中是不可分割的，要么全部完成，要么均不执行</li><li>一致性(Consistency)：几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致</li><li>隔离性(Isolation)：事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的</li><li>持久性(Durability)：对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障</li></ul></li><li>要求：表的类型必须是innodb或bdb类型，才可以对此表使用事务</li></ul><p>查看表的创建语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create table students;</span><br></pre></td></tr></table></figure><p>修改表的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table &apos;表名&apos; engine=innodb;</span><br></pre></td></tr></table></figure><ul><li>事务语句<ul><li>开启begin;</li><li>提交commit;</li><li>回滚rollback;</li></ul></li></ul><p>示例1</p><ul><li>步骤1：打开两个终端，连接mysql，使用同一个数据库，操作同一张表</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">终端1：</span><br><span class="line">select * from students;</span><br><span class="line">------------------------</span><br><span class="line">终端2：</span><br><span class="line">begin;</span><br><span class="line">insert into students(sname) values(&apos;张飞&apos;);</span><br><span class="line">步骤2</span><br><span class="line">终端1：</span><br><span class="line">select * from students;</span><br><span class="line">步骤3</span><br><span class="line">终端2：</span><br><span class="line">commit;</span><br><span class="line">------------------------</span><br><span class="line">终端1：</span><br><span class="line">select * from students;</span><br></pre></td></tr></table></figure><ul><li>示例2</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">步骤1：打开两个终端，连接mysql，使用同一个数据库，操作同一张表</span><br><span class="line">终端1：</span><br><span class="line">select * from students;</span><br><span class="line">------------------------</span><br><span class="line">终端2：</span><br><span class="line">begin;</span><br><span class="line">insert into students(sname) values(&apos;张飞&apos;);</span><br><span class="line">步骤2</span><br><span class="line">终端1：</span><br><span class="line">select * from students;</span><br><span class="line">步骤3</span><br><span class="line">终端2：</span><br><span class="line">rollback;</span><br><span class="line">------------------------</span><br><span class="line">终端1：</span><br><span class="line">select * from students;</span><br></pre></td></tr></table></figure><h2 id="于python交互"><a href="#于python交互" class="headerlink" title="于python交互"></a>于python交互</h2><h3 id="交互类型"><a href="#交互类型" class="headerlink" title="交互类型"></a>交互类型</h3><ul><li>在文件中引入模块</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Mysqldb</span><br></pre></td></tr></table></figure><h5 id="Connection对象"><a href="#Connection对象" class="headerlink" title="Connection对象"></a>Connection对象</h5><p>用于建立与数据库的连接</p><ul><li>创建对象：调用connect()方法<br><code>conn=connect(参数列表)</code><ul><li>参数host：连接的mysql主机，如果本机是’localhost’</li><li>参数port：连接的mysql主机的端口，默认是3306</li><li>参数db：数据库的名称</li><li>参数user：连接的用户名</li><li>参数password：连接的密码</li><li>参数charset：通信采用的编码方式，默认是’gb2312’，要求与数据库创建时指定的编码一致，否则中文会乱码</li></ul></li><li>对象的方法<ul><li>close()关闭连接</li><li>commit()事务，所以需要提交才会生效</li><li>rollback()事务，放弃之前的操作</li><li>cursor()返回Cursor对象，用于执行sql语句并获得结果<h5 id="Cursor对象"><a href="#Cursor对象" class="headerlink" title="Cursor对象"></a>Cursor对象</h5>执行sql语句</li></ul></li><li>创建对象：调用Connection对象的cursor()方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cursor1=conn.cursor()</span><br></pre></td></tr></table></figure><ul><li>对象的方法<ul><li>close()关闭</li><li>execute(operation [, parameters ])执行语句，返回受影响的行数</li><li>fetchone()执行查询语句时，获取查询结果集的第一个行数据，返回一个元组</li><li>next()执行查询语句时，获取当前行的下一行</li><li>fetchall()执行查询时，获取结果集的所有行，一行构成一个元组，再将这些元组装入一个元组返回</li><li>scroll(value[,mode])将行指针移动到某个位置</li><li>mode表示移动的方式</li><li>mode的默认值为relative，表示基于当前行移动到value，value为正则向下移动，value为负则向上移动</li><li>mode的值为absolute，表示基于第一条数据的位置，第一条数据的位置为0</li><li>对象的属性</li><li>rowcount只读属性，表示最近一次execute()执行后受影响的行数</li><li>connection获得当前连接对象<h5 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h5>创建testInsert.py文件，向学生表中插入一条数据</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf-8</span><br><span class="line">import MySQLdb</span><br><span class="line">try:</span><br><span class="line">    conn=MySQLdb.connect(host=&apos;localhost&apos;,port=3306,db=&apos;test1&apos;,user=&apos;root&apos;,passwd=&apos;mysql&apos;,charset=&apos;utf8&apos;)</span><br><span class="line">    cs1=conn.cursor()</span><br><span class="line">    count=cs1.execute(&quot;insert into students(sname) values(&apos;张良&apos;)&quot;)</span><br><span class="line">    print count</span><br><span class="line">    conn.commit()</span><br><span class="line">    cs1.close()</span><br><span class="line">    conn.close()</span><br><span class="line">except Exception,e:</span><br><span class="line">    print e.message</span><br></pre></td></tr></table></figure><h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><p>创建testUpdate.py文件，修改学生表的一条数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import MySQLdb</span><br><span class="line">try:</span><br><span class="line">    conn=MySQLdb.connect(host=&apos;localhost&apos;,port=3306,db=&apos;test1&apos;,user=&apos;root&apos;,passwd=&apos;mysql&apos;,charset=&apos;utf8&apos;)</span><br><span class="line">    cs1=conn.cursor()</span><br><span class="line">    count=cs1.execute(&quot;update students set sname=&apos;刘邦&apos; where id=6&quot;)</span><br><span class="line">    print count</span><br><span class="line">    conn.commit()</span><br><span class="line">    cs1.close()</span><br><span class="line">    conn.close()</span><br><span class="line">except Exception,e:</span><br><span class="line">    print e.message</span><br></pre></td></tr></table></figure><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><p>创建testDelete.py文件，删除学生表的一条数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#encoding=utf-8</span><br><span class="line">import MySQLdb</span><br><span class="line">try:</span><br><span class="line">    conn=MySQLdb.connect(host=&apos;localhost&apos;,port=3306,db=&apos;test1&apos;,user=&apos;root&apos;,passwd=&apos;mysql&apos;,charset=&apos;utf8&apos;)</span><br><span class="line">    cs1=conn.cursor()</span><br><span class="line">    count=cs1.execute(&quot;delete from students where id=6&quot;)</span><br><span class="line">    print count</span><br><span class="line">    conn.commit()</span><br><span class="line">    cs1.close()</span><br><span class="line">    conn.close()</span><br><span class="line">except Exception,e:</span><br><span class="line">    print e.message</span><br><span class="line">SQL语句参数化</span><br><span class="line">创建testInsertParam.py文件，向学生表中插入一条数据</span><br><span class="line">#encoding=utf-8</span><br><span class="line">import MySQLdb</span><br><span class="line">try:</span><br><span class="line">    conn=MySQLdb.connect(host=&apos;localhost&apos;,port=3306,db=&apos;test1&apos;,user=&apos;root&apos;,passwd=&apos;mysql&apos;,charset=&apos;utf8&apos;)</span><br><span class="line">    cs1=conn.cursor()</span><br><span class="line">    sname=raw_input(&quot;请输入学生姓名：&quot;)</span><br><span class="line">    params=[sname]</span><br><span class="line">    count=cs1.execute(&apos;insert into students(sname) values(%s)&apos;,params)</span><br><span class="line">    print count</span><br><span class="line">    conn.commit()</span><br><span class="line">    cs1.close()</span><br><span class="line">    conn.close()</span><br><span class="line">except Exception,e:</span><br><span class="line">    print e.message</span><br></pre></td></tr></table></figure><h5 id="其它语句"><a href="#其它语句" class="headerlink" title="其它语句"></a>其它语句</h5><p>cursor对象的execute（）方法，也可以用于执行create table等语句<br>建议在开发之初，就创建好数据库表结构，不要在这里执行</p><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MySqlhelper:</span><br><span class="line"></span><br><span class="line">    def __init__(self, host, db, user, pwd, port=3306, charset=&quot;utf8&quot;):</span><br><span class="line">        self.host = host</span><br><span class="line">        self.port = port</span><br><span class="line">        self.db = db</span><br><span class="line">        self.user = user</span><br><span class="line">        self.passwd = pwd</span><br><span class="line">        self.charset = charset</span><br><span class="line"></span><br><span class="line">    def connect(self):</span><br><span class="line">        self.conn = pymysql.connect(</span><br><span class="line">            host=self.host,</span><br><span class="line">            port=self.port,</span><br><span class="line">            db=self.db,</span><br><span class="line">            user=self.user,</span><br><span class="line">            passwd=self.passwd,</span><br><span class="line">            charset=self.charset</span><br><span class="line">        )</span><br><span class="line">        self.cursor = self.conn.cursor()</span><br><span class="line"></span><br><span class="line">    def close(self):</span><br><span class="line">        self.cursor.close()</span><br><span class="line">        self.conn.close()</span><br><span class="line"></span><br><span class="line">    # private api</span><br><span class="line">    def __edit(self, sql, param):</span><br><span class="line">        count = 0</span><br><span class="line">        try:</span><br><span class="line">            self.connect()</span><br><span class="line">            self.cursor.execute(sql, param)</span><br><span class="line">            self.conn.commit()</span><br><span class="line">            self.close()</span><br><span class="line">        except Exception as result:</span><br><span class="line">            print(result)</span><br><span class="line">        else:</span><br><span class="line">            return count</span><br><span class="line"></span><br><span class="line">    # 插入</span><br><span class="line">    def insert(self, sql, params=()):</span><br><span class="line">        return self.__edit(sql, params)</span><br><span class="line"></span><br><span class="line">    # 更改</span><br><span class="line">    def update(self, sql, params=()):</span><br><span class="line">        return self.__edit(sql, params)</span><br><span class="line"></span><br><span class="line">    # 删除</span><br><span class="line">    def delete(self, sql, params=()):</span><br><span class="line">        return self.__edit(sql, params)</span><br><span class="line"></span><br><span class="line">    def get_one(self, sql):</span><br><span class="line">        result = None</span><br><span class="line">        try:</span><br><span class="line">            self.connect()</span><br><span class="line">            self.cursor.execute(sql)</span><br><span class="line">            result = self.cursor.fetchone()</span><br><span class="line">            self.close()</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(e)</span><br><span class="line">        else:</span><br><span class="line">            return result</span><br><span class="line"></span><br><span class="line">    def get_all(self, sql):</span><br><span class="line">        result = []</span><br><span class="line">        try:</span><br><span class="line">            self.connect()</span><br><span class="line">            self.cursor.execute(sql)</span><br><span class="line">            result = self.cursor.fetchall()</span><br><span class="line">            self.close()</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(e)</span><br><span class="line">        else:</span><br><span class="line">            return result</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;使用命令开启、连接&quot;&gt;&lt;a href=&quot;#使用命令开启、连接&quot; class=&quot;headerlink&quot; title=&quot;使用命令开启、连接&quot;&gt;&lt;/a&gt;使用命令开启、连接&lt;/h2&gt;&lt;figure class=&quot;highlight pl
      
    
    </summary>
    
      <category term="Python" scheme="https://github.com/anru1314/categories/Python/"/>
    
    
      <category term="MySql" scheme="https://github.com/anru1314/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>自定义转场动画</title>
    <link href="https://github.com/anru1314/2018/10/09/iOS/2018-10-09-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/"/>
    <id>https://github.com/anru1314/2018/10/09/iOS/2018-10-09-自定义转场动画/</id>
    <published>2018-10-09T08:27:07.000Z</published>
    <updated>2018-11-16T13:48:27.383Z</updated>
    
    <content type="html"><![CDATA[<hr><p>最近搭组件框架，发现转场动画有点毛病，就过来再屡屡！<a href="">Demo</a></p><h3 id="官方支持的4种自定义转场"><a href="#官方支持的4种自定义转场" class="headerlink" title="官方支持的4种自定义转场"></a>官方支持的4种自定义转场</h3><ol><li>常用的，使用栈视图控制器 <code>UINavigationController</code> 进行 push 和 pop</li><li><code>Modal</code> 转场：<code>presentation</code> 和 <code>dismissal</code>，这种方式只能在<code>modalPresentationStyle</code>属性为 <code>UIModalPresentationFullScreen</code> 或 <code>UIModalPresentationCustom</code>这两种模式</li><li><code>UICollectionViewController</code> 的布局转场：仅限于 <code>UICollectionViewController</code> 与 <code>UINavigationController</code> 结合的转场方式 </li><li><code>UITabBarController</code> 中切换 Tab</li></ol><p>前2种在以往用的比较多，所以暂时写了前2种</p><h3 id="学习准备"><a href="#学习准备" class="headerlink" title="学习准备"></a>学习准备</h3><ul><li><strong>转换动画</strong>：一个控制器的内容交换为另一个控制器的内容</li></ul><h4 id="转场代理-Transitioning-Delegate"><a href="#转场代理-Transitioning-Delegate" class="headerlink" title="转场代理 (Transitioning Delegate)"></a>转场代理 (Transitioning Delegate)</h4><p>转场代理：定义并遵守 <strong>以下</strong> 协议的对象。它的工作是为UIKit提供以下对象：<br>（若不提供，则默认使用视图控制器的modalTransitionStyle中的标准转场动画）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">三种转场代理，对应三种转场类型，这里只讲前2种</span><br><span class="line"></span><br><span class="line">//push、pop</span><br><span class="line">&lt;UINavigationControllerDelegate&gt; //UINavigationController 的 delegate 属性遵守该协议。</span><br><span class="line"></span><br><span class="line">//tab转换</span><br><span class="line">&lt;UITabBarControllerDelegate&gt; //UITabBarController 的 delegate 属性遵守该协议。</span><br><span class="line"></span><br><span class="line">//modal</span><br><span class="line">&lt;UIViewControllerTransitioningDelegate&gt; //UIViewController 的 transitioningDelegate 属性遵守该协议。</span><br></pre></td></tr></table></figure><ul><li><h5 id="动画对象-animator-objects"><a href="#动画对象-animator-objects" class="headerlink" title="动画对象 (animator objects)"></a>动画对象 (animator objects)</h5>负责创建用于显示或隐藏视图控制器视图的动画。动画对象遵守<code>UIViewControllerAnimatedTransitioning</code>协议。</li></ul><ul><li><h5 id="交互式动画对象-Interactive-animator-objects"><a href="#交互式动画对象-Interactive-animator-objects" class="headerlink" title="交互式动画对象 (Interactive animator objects)"></a>交互式动画对象 (Interactive animator objects)</h5><p>交互式动画对象使用触摸事件或手势识别器来驱动自定义动画的时间。交互式动画对象遵守 <code>UIViewControllerInteractiveTransitioning</code>协议。</p><p>  创建交互式动画制作者的最简单方法是将<code>UIPercentDrivenInteractiveTransition</code>子类化并将事件处理代码添加到子类中。该类控制使用现有动画对象创建的动画的时间。如果您创建自己的交互式动画制作者，则必须自己渲染动画的每个帧。</p><p>  我构建过程中也是继承<code>UIPercentDrivenInteractiveTransition</code>实现的</p></li></ul><blockquote><p>这三者之间的关系就好比是我们手动翻书：我们自己本身遵守<code>UIViewControllerTransitioningDelegate</code>,告诉手<code>UIViewControllerInteractiveTransitioning</code>,应该以什么样的姿势<code>UIViewControllerAnimatedTransitioning</code>翻动到下一页</p></blockquote><p>我们本身很重要，既要提供手，还有摆姿势！</p><p><strong>这些协议都是iOS 7 以后开放的</strong></p><h5 id="转场上下文-Transition-Context"><a href="#转场上下文-Transition-Context" class="headerlink" title="转场上下文(Transition Context):"></a>转场上下文(Transition Context):</h5><p>遵守<code>&lt;UIViewControllerContextTransitioning&gt;</code>协议</p><p>再转场动画开始前，UIKit会帮我们创建一个转场上下文，存储有关如何执行转场的信息，包括动画是否是交互式的</p><ul><li>在其<code>animateTransition：</code>和<code>transitionDuration：</code>方法以及<code>startInteractiveTransition：</code>方法中的交互控制器中传递给动画对象。<ul><li>如果存在交互控制器，则首先调用其<code>startInteractiveTransition：</code>并将其调用到交互控制器对象，以便在需要时调用<code>animateTransition：</code>方法。</li><li>如果没有交互控制器，则系统会自动调用动画师的<code>animateTransition：</code>方法。</li></ul></li><li>提供<code>viewControllerForKey：</code>，<code>initialFrameForViewController：</code> 和<code>finalFrameForViewController：</code> 方法，获取转场相关信息</li></ul><h5 id="转场协调器-Transition-Coordinator-："><a href="#转场协调器-Transition-Coordinator-：" class="headerlink" title="转场协调器(Transition Coordinator)："></a>转场协调器(Transition Coordinator)：</h5><p>遵守<code>&lt;UIViewControllerTransitionCoordinator&gt;</code>协议<br>也是由UIKit都会创建的，视图控制器的present/dissmiss、界面旋转、frame发时发生的转场，这些变化都会造成视图层级结构的更改，协调器就是跟踪这些更改并同时为您自己的内容制作动画的方法。但<strong>仅在转场期间存在</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可通过get方法获取</span><br><span class="line">@property(nonatomic, readonly, nullable) id &lt;UIViewControllerTransitionCoordinator&gt; transitionCoordinator NS_AVAILABLE_IOS(7_0);</span><br></pre></td></tr></table></figure><p>主要在 Modal 转场和交互转场取消时使用，其他时候很少用到</p><h3 id="UINavigationController-使用中-push-和-pop"><a href="#UINavigationController-使用中-push-和-pop" class="headerlink" title="UINavigationController 使用中 push 和 pop"></a>UINavigationController 使用中 push 和 pop</h3><p>转场代理：<code>UINavigationControllerDelegate</code> （iOS 2就有了，只是到7扩充成协议便于自定义）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*返回已经实现的`动画控制器`，如果返回nil则使用系统默认的动画效果*/</span><br><span class="line">- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController animationControllerForOperation:(UINavigationControllerOperation)operation  fromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC  NS_AVAILABLE_IOS(7_0);</span><br><span class="line"></span><br><span class="line">/*返回已经实现的`交互控制器`，如果返回nil则不支持手势交互*/</span><br><span class="line">- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController *)navigationController interactionControllerForAnimationController:(id &lt;UIViewControllerAnimatedTransitioning&gt;) animationController NS_AVAILABLE_IOS(7_0);</span><br></pre></td></tr></table></figure><ol><li>自定义转场动画对象</li><li>自定义交互动画对象（及上面提到的自定义<code>UIPercentDrivenInteractiveTransition</code> 子类）<ul><li>实现手势驱动</li></ul></li><li>实现<code>UINavigationControllerDelegate</code> 代理<ul><li>返回转场动画对象，交互动画对象</li></ul></li></ol><ul><li><strong>注意</strong>：如果在转场代理中提供了交互动画对象，而转场发生时<strong>并没有方法来驱动转场进</strong>程(比如手势)，<strong>转场过程将一直处于开始阶段无法结束，应用界面也会失去响应</strong>：在 NavigationController 中点击 NavigationBar 也能实现 pop 返回操作，但此时没有了交互手段的支持，转场过程卡壳；</li></ul><h3 id="Modal-转场：presentation-和-dismissal"><a href="#Modal-转场：presentation-和-dismissal" class="headerlink" title="Modal 转场：presentation 和 dismissal"></a>Modal 转场：presentation 和 dismissal</h3><p>转场代理： <code>UIViewControllerTransitioningDelegate</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@protocol UIViewControllerTransitioningDelegate &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@optional</span><br><span class="line">/*present时调用，返回已经实现的`动画控制器`*/</span><br><span class="line">- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source;</span><br><span class="line"></span><br><span class="line">/*dissmis时调用，返回已经实现的`动画控制器`*/</span><br><span class="line">- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed;</span><br><span class="line"></span><br><span class="line">/*交互动画present时调用，返回已经实现的`交互控制器`*/</span><br><span class="line">- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForPresentation:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator;</span><br><span class="line"></span><br><span class="line">/*交互动画dissmiss时调用，返回已经实现的`交互控制器`*/</span><br><span class="line">- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForDismissal:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator;</span><br><span class="line"></span><br><span class="line">/*ios8新增的协议*/</span><br><span class="line">- (nullable UIPresentationController *)presentationControllerForPresentedViewController:(UIViewController *)presented presentingViewController:(nullable UIViewController *)presenting sourceViewController:(UIViewController *)source NS_AVAILABLE_IOS(8_0);</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>Modal 转场的代理协议<code>UIViewControllerTransitioningDelegate</code>是 iOS 7 新增的，其为 <code>presentation</code> 和 <code>dismissal</code> 转场分别提供了动画控制器。<br>iOS8引入了<code>UIPresentationController</code>类，该类接管了 UIViewController 的显示过程。<br>可通过自定义<code>UIPresentationController</code>的子类，覆盖相关方法</p><ol><li>自定义转场动画对象</li><li>自定义交互动画对象（及上面提到的自定义<code>UIPercentDrivenInteractiveTransition</code> 子类）<ul><li>实现手势驱动</li></ul></li><li>实现<code>UIPresentationController</code>子类，<ul><li>重写父类方法，实现复杂的视图及动画</li></ul></li><li>实现<code>UIViewControllerTransitioningDelegate</code> 转场代理<ul><li>返回转场动画对象，交互动画对象</li></ul></li></ol><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><blockquote><ul><li>转换完成后，所有自定义动画都必须调用上下文的<code>completeTransition：</code>方法。此外，动画应该在上下文指定的<code>containerView</code>中进行。对于交互式转换，应在交互式动画进行时调用上下文的<code>updateInteractiveTransition：</code>，<code>finishInteractiveTransition</code>或<code>cancelInteractiveTransition</code>。 </li></ul></blockquote><blockquote><ul><li><code>UIPercentDrivenInteractiveTransition</code>类提供了<code>UIViewControllerInteractiveTransitioning</code>协议的实现，该协议可用于交互式驱动由动画对象创建的任何UIView属性动画。</li><li>Model中，在 Custom 模式下的 dismissal转场中不要像其他的转场那样将 toView(presentingView) 加入 containerView，否则presentingView将消失不见，而应用则也很可能假死。而 FullScreen 模式下可以使用与前面的容器类 VC 转场同样的代码,<strong>(Modal 转场在 Custom 模式下必须区分 presentation 和 dismissal 转场，而在 FullScreen 模式下可以不用这么做</strong>)。</li></ul></blockquote><h3 id="示例图"><a href="#示例图" class="headerlink" title="示例图"></a>示例图</h3><p><img src="/images/iOS/2018-10-09-自定义转场动画/示例图.gif" alt=""></p><h3 id="推荐文章："><a href="#推荐文章：" class="headerlink" title="推荐文章："></a>推荐文章：</h3><ul><li><p><a href="https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/DefiningYourSubclass.html#//apple_ref/doc/uid/TP40007457-CH7-SW1" target="_blank" rel="noopener">官方文档：View Controller Programming Guide for iOS</a></p></li><li><p><a href="https://github.com/seedante/iOS-Note/wiki/ViewController-Transition#Chapter0">seedante的iOS 视图控制器转场详解</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;最近搭组件框架，发现转场动画有点毛病，就过来再屡屡！&lt;a href=&quot;&quot;&gt;Demo&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;官方支持的4种自定义转场&quot;&gt;&lt;a href=&quot;#官方支持的4种自定义转场&quot; class=&quot;headerlink&quot; title=&quot;官方支持的4种自定义
      
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/anru1314/categories/iOS/"/>
    
    
      <category term="自定义转场动画" scheme="https://github.com/anru1314/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>iOS 定时器</title>
    <link href="https://github.com/anru1314/2018/10/09/iOS/2018-10-09-%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    <id>https://github.com/anru1314/2018/10/09/iOS/2018-10-09-定时器/</id>
    <published>2018-10-09T08:23:23.000Z</published>
    <updated>2018-11-16T13:48:02.352Z</updated>
    
    <content type="html"><![CDATA[<h4 id="NSTimer-简单介绍"><a href="#NSTimer-简单介绍" class="headerlink" title="NSTimer 简单介绍"></a>NSTimer 简单介绍</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 创建方式一</span><br><span class="line">    NSTimer *timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(fire) userInfo:nil repeats:YES];</span><br><span class="line">    </span><br><span class="line">// 创建方式二</span><br><span class="line">     NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(fire) userInfo:nil repeats:YES];</span><br><span class="line">     </span><br><span class="line">// 值得一提的是iOS 10 以后分别为2种方式增加 block 回调，用来处理循环引用问题</span><br><span class="line">+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block ;</span><br><span class="line">+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block</span><br></pre></td></tr></table></figure><ul><li><p>方式一<br>  创建定时器后需要手动将定时器添加到<code>runLoop</code>,否则不会执行</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>方式二<br>  会自动将创建的定时器以<strong>默认模式</strong>添加到<code>runLoop</code>中，当<strong>屏幕滚动时<code>runLoop</code>则会进入另外一种模式<code>TrackingRunLoopMode</code>，导致定时器暂停</strong>，所以一般我们也需要将其手动添加到<code>NSRunLoopCommonModes</code> 中</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSRunLoopCommonModes = NSDefaultRunLoopMode + UITrackingRunLoopMode</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>对于重复定时器，必须通过调用其<code>invalidate</code>方法来自行使定时器对象无效。调用此方法，将<strong>定时器从当前运行循环中删除</strong>; 所以，调用<code>invalidate</code>必须和构建定时器时，<strong>保持在同一线程</strong>中，这样就可以使计时器立即失效会并禁用，就不会再影响运行循环。</p></blockquote><h4 id="精准度"><a href="#精准度" class="headerlink" title="精准度"></a>精准度</h4><p>我们都知道NSTimer会有精度问题，但是是怎么造成的呢？</p><blockquote><ol><li>定时器计算下一个触发时间是根据<strong>初始触发时间</strong>计算的，下一次触发时间是定时器的整数倍+容差<code>tolerance</code></li><li>定时器是添加到<code>runloop</code>中的。如果<code>runloop</code>阻塞了，调用或执行方法所花费的时间长于指定的时间间隔（第1点计算得到的时间，就会推迟到下一个<code>runloop</code>周期。</li><li>定时器是不会尝试补偿在调用或执行指定方法时可能发生的任何错过的触发。</li></ol></blockquote><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>网上也有一些很好的解决方式:<a href="https://www.jianshu.com/p/2fe076e5e255" target="_blank" rel="noopener">通过分类增加block</a>，实现方式跟系统提供的一样<br>在博客里作者也很好的解释了循环引用问题</p><p><img src="/images/iOS/2018-10-09-定时器/循环引用.jpg" alt=""></p><ul><li><p>Runloop对定时源的观察者要进行保留以便时间点到了进行调用，即定时器对象被Runloop强保留着，而定时器内部持有控制器的target，控制器为了方便后续使用，又持有了定时器。这就造成了循环使用。</p><p>  虽然系统提供了<code>invalidate</code>来是定时器失效，但是应该在哪里调用这个方法合适呢？delloc？不可能的了！</p></li></ul><p>这里我介绍一种<code>YYKit</code>里面的方法，利用消息转发实现的，这种方式相对方便，也适用在<code>CADisplayLink</code>造成的内存泄漏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个继承自NSProxy的子类</span><br><span class="line">- (instancetype)initWithTarget:(id)target</span><br><span class="line">&#123;</span><br><span class="line">    _target = target;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">+ (instancetype)proxyWithTarget:(id)target</span><br><span class="line">&#123;</span><br><span class="line">    return [[ANWeakProxy alloc] initWithTarget:target];</span><br><span class="line">&#125;</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)selector &#123;</span><br><span class="line">    return _target;</span><br><span class="line">&#125;</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)invocation &#123;</span><br><span class="line">    void *null = NULL;</span><br><span class="line">    [invocation setReturnValue:&amp;null];</span><br><span class="line">&#125;</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector &#123;</span><br><span class="line">    return [NSObject instanceMethodSignatureForSelector:@selector(init)];</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)respondsToSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    return [_target respondsToSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>使用：</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@implementation MyView &#123;</span><br><span class="line">    NSTimer *_timer;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> - (void)initTimer &#123;</span><br><span class="line">    ANWeakProxy *proxy = [ANWeakProxy proxyWithTarget:self];</span><br><span class="line">    _timer = [NSTimer timerWithTimeInterval:1 target:proxy selector:@selector(tick:) userInfo:nil repeats:YES];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> - (void)tick:(NSTimer *)timer &#123;...&#125;</span><br><span class="line"> @end</span><br></pre></td></tr></table></figure><h3 id="CADisplayLink"><a href="#CADisplayLink" class="headerlink" title="CADisplayLink"></a>CADisplayLink</h3><h4 id="CADisplayLink-简单介绍"><a href="#CADisplayLink-简单介绍" class="headerlink" title="CADisplayLink 简单介绍"></a>CADisplayLink 简单介绍</h4><p><code>CADisplayLink</code> 是一个能让我们以<strong>和屏幕刷新率同步的频率</strong>将特定的内容画到屏幕上的<strong>定时器类</strong></p><ul><li><strong>每当屏幕显示内容刷新结束的时候</strong>，runloop就会向CADisplayLink指定的target发送一次指定的selector消息，CADisplayLink类对应的selector就会被调用一次，所以可以使用CADisplayLink做一些和屏幕操作相关的操作。</li><li>NSTimer 以指定的模式注册到 RunLoop 后，<strong>每当指定的时间到达后</strong>，RunLoop 会向指定的 target 发送一次指定的 selector 消息。</li></ul><p>同NSTimer一样，也会因为同样的问题造成精度问题。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去，造成界面卡顿的感觉。</p><ul><li>创建方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CADisplayLink *displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(fire)];</span><br><span class="line">    [displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure><p>CADisplayLink、NSTimer 都只能添加到一个runloop中，但是可以多模式</p><h4 id="内存泄漏-1"><a href="#内存泄漏-1" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><p>与<code>NSTimer</code> 类似，会出现循环引用。<br>解决方法同<code>NSTimer</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_link = [CADisplayLink displayLinkWithTarget:[ANWeakProxy proxyWithTarget:self] selector:@selector(fire)];</span><br></pre></td></tr></table></figure><h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><h4 id="dispatch-source-t-的使用"><a href="#dispatch-source-t-的使用" class="headerlink" title="dispatch_source_t 的使用"></a>dispatch_source_t 的使用</h4><p>关于GCD定时器探究，这里介绍一篇比较清晰的文章 <a href="https://www.jianshu.com/p/3459ff04104d" target="_blank" rel="noopener">iOS倒计时的探究与选择</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_requestTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0,dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0));</span><br><span class="line"></span><br><span class="line">//设置GCD定时器</span><br><span class="line">if (_requestTimer) &#123;</span><br><span class="line">    dispatch_source_set_timer(_requestTimer,dispatch_walltime(NULL, 0), requestTimeMargin * NSEC_PER_SEC, 0);</span><br><span class="line">    dispatch_source_set_event_handler(_requestTimer, ^&#123;</span><br><span class="line">        // do something</span><br><span class="line">    &#125;);</span><br><span class="line">    // GCD定时器启动，默认是关闭的</span><br><span class="line">    dispatch_resume(_requestTimer);</span><br><span class="line">    NSLog(@&quot;定时器开启&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NSObject-中的performSelector"><a href="#NSObject-中的performSelector" class="headerlink" title="NSObject 中的performSelector"></a>NSObject 中的performSelector</h3><p>这种一次性的定时器相对于 GCD 中的 <code>dispatch_after</code>，使用还是比较少的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray&lt;NSRunLoopMode&gt; *)modes;</span><br><span class="line"></span><br><span class="line">- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;</span><br></pre></td></tr></table></figure><p>与NSTimer <code>scheduledTimerWithTimeInterval</code> 类似，在内部会帮我们创建NSTimer的同时，添加到当前线程的runloop中</p><p>如果线程是主线程（程序一启动，就默认开启主线程的runloop），而我们创建的子线程的runloop默认是关闭的，不手动激活，而且基于NSTimer，精度问题也存在！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;NSTimer-简单介绍&quot;&gt;&lt;a href=&quot;#NSTimer-简单介绍&quot; class=&quot;headerlink&quot; title=&quot;NSTimer 简单介绍&quot;&gt;&lt;/a&gt;NSTimer 简单介绍&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/anru1314/categories/iOS/"/>
    
    
      <category term="定时器" scheme="https://github.com/anru1314/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    
  </entry>
  
</feed>
